Функциональный интерфейс
https://job4j.ru/profile/exercise/33/task/238/232578
появились в Java версии 8
https://struchkov.dev/blog/ru/java-stream-api/ Глубокое погружение в Stream API Java: Понимание и Применение
https://habr.com/ru/articles/677610/ Функциональные интерфейсы в Java 8 → Consumer, Supplier, Predicate и Function. Что к чему и зачем нужны

Функциональный интерфейс - это интерфейс, который содержит только один абстрактный метод. Абстрактный метод - это метод в котором нет реализации.

1. Supplier.

Supplier (поставщик) используется для создания какого-либо объекта и при этом ему не требуется входной параметр. В стандартной библиотеке Java интерфейс представлен в следующем виде:

@FunctionalInterface
public interface Supplier<T> {
    T get();
}

Supplier<String> supplier = () -> "New String For Interface";
Consumer<String> consumer = (string) -> System.out.println(string);
consumer.accept(supplier.get());

2. Consumer и BiConsumer.

Consumer (потребитель) используется в том случае, если нам нужно применить какое-то действие или операцию к параметру (для BiConsumer два параметра) и при этом у метода нет возвращаемого значения. Объявляются эти интерфейсы следующим образом:

java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}
@FunctionalInterface
public interface BiConsumer<T, U> {
    void accept(T t, U u);
}
Два интерфейса отличаются только одним – количеством параметров, которые принимает метод в этом интерфейсе. Это относится ко всем интерфейсам – если видите приставку Bi – значит отличие лишь в количестве параметров. Вернемся к ранее написанному примеру и перепишем вывод в консоль на применение интерфейса Consumer:

peek(Consumer)
Метод peek() создает новый поток, идентичный исходному, но с дополнительной операцией, применяемой к каждому элементу при его прохождении по конвейеру потока.

List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

numbers.stream()
       .peek(System.out::println)
       .collect(Collectors.toList());
В данном примере, метод peek() применяется к потоку чисел. Consumer, переданный в метод peek(), выводит каждый элемент на консоль. В процессе этого, каждый элемент, проходя по конвейеру потока, отображается на консоли, но сам поток остается неизменным.

Метод peek() удобен, когда необходимо выполнить дополнительные операции с элементами потока, например, для целей логирования, отладки или профилирования, не меняя при этом сами элементы. Но важно быть осторожным с его использованием, так как неправильное применение метода peek() может привести к нежелательным последствиям.

Поскольку peek() – это промежуточная операция, которая не предназначена для изменения элементов потока, непреднамеренные изменения могут вызвать непредсказуемые результаты при параллельном выполнении потока.

В общем случае, рекомендуется использовать peek() редко и, преимущественно, для отладки, а не как средство модификации элементов потока. Если требуется изменить элементы потока, предпочтительнее использовать метод map().

3. Predicate (BiPredicate).

Predicate (утверждение) наиболее часто применяется в фильтрах и сравнении и объявляются они следующим образом:

@FunctionalInterface
public interface Predicate<T> {

    boolean test(T t);
}
@FunctionalInterface
public interface BiPredicate<T, U> {

    boolean test(T t, U u);
}
Т.е. в метод test() передается один или два параметра, в зависимости от функционального интерфейса и возвращает логическое значение true или false. Посмотрим, как это работает на простом примере – проверим не является ли передаваемая строка пустой:

Predicate<String> predicate = string -> string.isEmpty();
System.out.println("Строка пустая: " + predicate.test(""));
System.out.println("Строка пустая: " + predicate.test("test"));

filter(Predicate)
Этот метод используется для создания нового потока, включающего только элементы, которые удовлетворяют определенному условию. В качестве аргумента метод принимает функциональный интерфейс Predicate, задающий условие фильтрации.

Вот пример использования метода filter() для создания нового потока, который включает только четные числа из списка целых чисел.

4. Function (BiFunction).

Function используется для преобразования входного параметра или двух параметров (для Bi-формы этого функционального интерфейса) в какое-либо значение, тип возвращаемого значения может не совпадать с типом входных параметров. Объявляются интерфейсы следующим образом:

java
@FunctionalInterface
public interface Function<T, R> {

    R apply(T t);
}
@FunctionalInterface
public interface BiFunction<T, U, R> {

    R apply(T t, U u);
}
Попробуем прочитать символ с определенным индексом в строке с помощью функционального интерфейса:

java
Function<String, Character> function = string -> string.charAt(2);
System.out.println("Третий символ в строке: " + function.apply("first"));
System.out.println("Третий символ в строке: " + function.apply("second"));

map(Function)
Метод map() принимает в качестве аргумента функциональный интерфейс Function, задающий преобразование, применяемое к каждому элементу. Возвращаемый поток содержит преобразованные элементы.

Метод map() возвращает новый поток. Он не изменяет исходный поток и коллекцию. Обычно он используется для выполнения операций, таких как преобразование элементов из одного типа в другой.

List<String> words = Arrays.asList("apple", "banana", "orange", "peach");

Stream<Integer> lengthsStream = words.stream()
        .map(String::length);

lengthsStream.forEach(System.out::println); // prints 5, 6, 6, 5
В данном примере мы с помощью map() преобразовали строку в количество символов в строке, используя короткую запись лямбды (String::length), так называемую ссылку на метод.






