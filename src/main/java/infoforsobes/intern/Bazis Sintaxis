1) Содержимое файла

    1. Каждый файл java должен содержать класс.
    2. Внутри класса должны быть методы.
    3. Внутри методов находятся операторы.
    4. Операторы - это инструкции для выполнения.

2) Заголовок в файле java
    1. Папки, находящиеся в папке "src/main/java", принято называть пакетами.
    2. Пакет представляет собой именованную совокупность классов (и, возможно, подпакетов). Пакеты группируют классы и определяют пространства имен для классов, которые в них входят.
    3. Полное имя класса записывается как составное имя пакета, в котором находится файл, плюс название самого файла.
    4. В Java есть общепринятое правило: все классы должны находиться в пакетах. Считается плохим тоном располагать файлы сразу в папке  "src/main/java". Поэтому каждая компания для расположения файлов использует имена домена в обратном порядке.
       Вы проходите обучение на курсе www.job4j.ru, поэтому все файлы и подпакеты нужно будет располагать в пакете "ru.job4j".

3)  Процесс компиляции и запуска Java программы
    1. Чтобы запустить программу на языке Java, нужно текстовый файл с командами преобразовать в инструкции, понятные компьютеру.
    Этот процесс выполняет компилятор Java.
    Получившийся файл называется файлом с байт-кодом. Чтобы компьютер понял этот байт-код, его нужно запустить через виртуальную машину Java.
    Виртуальная машина позволяет запустить байт-код на любых операционных системах.
    Программист не тратит время на адаптацию программы для работы в Windows, Linux  или Mac. Это выполняет виртуальная машина Java (JVM).
    2. Виртуальная машина - это прослойка между вашей программой и операционной системой.
    https://job4j.ru/profile/exercise/1/task-view/19

4)  Порядок организации компонентов класса
https://topjava.ru/blog/pravila-formatirovaniya-koda-v-java2
    1. Компоненты класса должны располагаться в следующем порядке: пакет, импорты, объявление класса, статические переменные класса, переменные экземпляра, конструкторы, методы.

5)  Правила написания кода. Java Code Conventions. [#504935]
    1. Это соглашение, в котором описаны рекомендации к написанию базовых конструкций языка Java - оформление отступов, пробелов, наименование переменных, методов и т.д. Благодаря таким соглашениям унифицируется "почерк" разработчика. Код, написанный в едином стиле, проще читать, акцентируя внимание на деталях, а не на попытках понять как устроен сам код

6)  Что такое переменная. [#3610 #205475]
    Всё программирование сводится к хранению, передаче и изменению данных.
    Для этих операций в программировании есть понятие переменная.

    Переменная – это элементарный контейнер для хранения данных.

    Как и в реальной жизни, контейнеры создают для хранения определенных вещей. Например: жидкости, горючих или сыпучих веществ и т.д. То есть у каждого контейнера есть определенный тип хранимых данных.
    Для того, чтобы в Java создать переменную, необходимо использовать следующий шаблон.
    java
    ТИП_ДАННЫХ ИМЯ_ПЕРЕМЕННОЙ = ЗНАЧЕНИЕ_ПЕРЕМЕННОЙ;

7) Переменные и константы
    Переменные объявляются следующим образом: тип_данных имя_переменной; (int x;)
    Объявив переменную, мы можем присвоить ей значение:
    int x;      // объявление переменной
    x = 10;     // присвоение значения
    System.out.println(x);  // 10
    Также можно присвоить значение переменной при ее объявлении. Этот процесс называется инициализацией:
    Ключевое слово var
    Начиная с Java 10 в язык было добавлено ключевое слово var, которое также позволяет определять переменную:
    var x = 10;
    System.out.println(x);  // 10
    Слово var ставится вместо типа данных, а сам тип переменной выводится из того значения, которое ей присваивается. Например, переменной x присваивается число 10, значит, переменная будет представлять тип int.

    Но если переменная объявляется с помощью var, то мы обязательно должны инициализировать ее, то есть предоставить ей начальное значение, иначе мы получим ошибку, как, например, в следующем случае:
    var x;      // ! Ошибка, переменная не инициализирована
    x = 10;
    Константы
    Кроме переменных, в Java для хранения данных можно использовать константы. В отличие от переменных константам можно присвоить значение только один раз. Константа объявляется также, как и переменная, только вначале идет ключевое слово final:
    final int LIMIT = 5;
    System.out.println(LIMIT);  // 5
    // LIMIT=57; // так мы уже не можем написать, так как LIMIT - константа
    Как правило, константы имеют имена в верхнем регистре.

    Константы позволяют задать такие переменные, которые не должны больше изменяться. Например, если у нас есть переменная для хранения числа pi, то мы можем объявить ее константой, так как ее значение постоянно.

8)  Типы данных
    Одной из основных особенностей Java является то, что данный язык является строго типизированным. А это значит, что каждая переменная и константа представляет определенный тип и данный тип строго определен. Тип данных определяет диапазон значений, которые может хранить переменная или константа.
    boolean: хранит значение true или false
    byte: хранит целое число от -128 до 127 и занимает 1 байт
    short: хранит целое число от -32768 до 32767 и занимает 2 байта
    int: хранит целое число от -2 147 483 648 до 2 147 483 647 и занимает 4 байта
    long: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт
    double: хранит число с плавающей точкой от ±4.9*10-324 до ±1.7976931348623157*10308 и занимает 8 байт
    float: хранит число с плавающей точкой от -3.4*1038 до 3.4*1038 и занимает 4 байта
    float x = 8.5F;
    char: хранит одиночный символ в кодировке UTF-16 и занимает 2 байта, поэтому диапазон хранимых значений от 0 до 65535

9)  Арифметические операции
    В арифметических операциях участвуют числа. В Java есть бинарные арифметические операции (производятся над двумя операндами) и унарные (выполняются над одним операндом). К бинарным операциям относят следующие:
    + - * /
    При делении стоит учитывать, что если в операции участвуют два целых числа, то результат деления будет округляться до целого числа, даже если результат присваивается переменной float или double:
    double k = 10 / 4;     // 2
    System.out.println(k);
    Чтобы результат представлял число с плавающей точкой, один из операндов также должен представлять число с плавающей точкой:
    double k = 10.0 / 4;     // 2.5
    %
    получение остатка от деления двух чисел:
    int a = 33;
    int b = 5;
    int c = a % b;  // 3
    int d = 22 % 4; // 2 (22 - 4*5 = 2)
    Также есть две унарные арифметические операции, которые производятся над одним числом: ++ (инкремент) и -- (декремент). Каждая из операций имеет две разновидности: префиксная и постфиксная:
    ++ (префиксный инкремент)
    Предполагает увеличение переменной на единицу, например, z=++y (вначале значение переменной y увеличивается на 1, а затем ее значение присваивается переменной z)
    int a = 8;
    int b = ++a;
    System.out.println(a);  // 9
    System.out.println(b);  // 9
    ++ (постфиксный инкремент)
    Также представляет увеличение переменной на единицу, например, z=y++ (вначале значение переменной y присваивается переменной z, а потом значение переменной y увеличивается на 1)
    int a = 8;
    int b = a++;
    System.out.println(a);  // 9
    System.out.println(b);  // 8
    -- (префиксный декремент)
    уменьшение переменной на единицу, например, z=--y (вначале значение переменной y уменьшается на 1, а потом ее значение присваивается переменной z)
    int a = 8;
    int b = --a;
    System.out.println(a);  // 7
    System.out.println(b);  // 7
    -- (постфиксный декремент)
    z=y-- (сначала значение переменной y присваивается переменной z, а затем значение переменной y уменьшается на 1)
    int a = 8;
    int b = a--;
    System.out.println(a);  // 7
    System.out.println(b);  // 8

    Приоритет арифметических операций
    Одни операции имеют больший приоритет, чем другие, и поэтому выполняются вначале. Операции в порядке уменьшения приоритета:

    ++ (постфиксный инкремент), -- (постфиксный декремент)

    ++ (префиксный инкремент), -- (префиксный декремент)

    * (умножение), / (деление), % (остаток от деления)

    + (сложение), - (вычитание)

    Приоритет операций следует учитывать при выполнении набора арифметических выражений:
    int a = 8;
    int b = 7;
    int c = a + 5 * ++b;
    System.out.println(c);  // 48
    Вначале будет выполняться операция инкремента ++b, которая имеет больший приоритет - она увеличит значение переменной b и возвратит его в качестве результата. Затем выполняется умножение 5 * ++b, и только в последнюю очередь выполняется сложение a + 5 * ++b

    Скобки позволяют переопределить порядок вычислений:
    int a = 8;
    int b = 7;
    int c = (a + 5) * ++b;
    System.out.println(c);  // 104
    Несмотря на то, что операция сложения имеет меньший приоритет, но вначале будет выполняться именно сложение, а не умножение, так как операция сложения заключена в скобки.

    Ассоциативность операций
    Кроме приоритета операции отличаются таким понятием как ассоциативность. Когда операции имеют один и тот же приоритет, порядок вычисления определяется ассоциативностью операторов. В зависимости от ассоциативности есть два типа операторов:

    Левоассоциативные операторы, которые выполняются слева направо

    Правоассоциативные операторы, которые выполняются справа налево

    Так, некоторые операции, например, операции умножения и деления, имеют один и тот же приоритет. Какой же тогда будет результат в выражении:
    int x = 10 / 5 * 2;
    Стоит нам трактовать это выражение как (10 / 5) * 2 или как 10 / (5 * 2)? Ведь в зависимости от трактовки мы получим разные результаты.

    Все арифметические операторы (кроме префиксного инкремента и декремента) являются левоассоциативными, то есть выполняются слева направо. Поэтому выражение 10 / 5 * 2 необходимо трактовать как (10 / 5) * 2, то есть результатом будет 4.

    Операции с числами с плавающей точкой
    Следует отметить, что числа с плавающей точкой не подходят для финансовых и других вычислений, где ошибки при округлении могут быть критичными. Например:
    double d = 2.0 - 1.1;
    System.out.println(d);
    В данном случае переменная d будет равна не 0.9, как можно было бы изначально предположить, а 0.8999999999999999. Подобные ошибки точности возникают из-за того, что на низком уровне для представления чисел с плавающей точкой применяется двоичная система, однако для числа 0.1 не существует двоичного представления, также как и для других дробных значений. Поэтому в таких случаях обычно применяется класс BigDecimal, который позволяет обойти подобные ситуации.

    Небольшие выводы:

    1. Существуют различные математические операторы, которые позволяют вычислить сумму, разность, произведение, деление и остаток от деления;

    2. Существуют операторы инкремента (увеличение на 1) и декремента (уменьшение на 1) в пре-форме и пост-форме. Старайтесь использовать только пост-форму;

    3. В коде можно использовать составные операторы присваивания, которые сразу и вычисляют, и записывают результат вычисления в переменную, которая стоит слева от знака присваивания.

    4. Если значения слева и справа от знака присваивания имеют разный тип данных, то результат вычисления будет приведен к тому типу переменной, которая стоит слева от знака присваивания, при условии, что эти типы переменных совместимы. Например: long = int, double = float. В остальных случаях нужно применять явное приведение типов.

10) Условные выражения
    == != > < >= <=
11)    Логические операции
    Также в Java есть логические операции, которые также представляют условие и возвращают true или false и обычно объединяют несколько операций сравнения. К логическим операциям относят следующие:

    |

    c=a|b; (c равно true, если либо a, либо b (либо и a, и b) равны true, иначе c будет равно false)

    &

    c=a&b; (c равно true, если и a, и b равны true, иначе c будет равно false)

    !

    c=!b; (c равно true, если b равно false, иначе c будет равно false)

    ^

    c=a^b; (c равно true, если либо a, либо b (но не одновременно) равны true, иначе c будет равно false)

    ||

    c=a||b; (c равно true, если либо a, либо b (либо и a, и b) равны true, иначе c будет равно false)

    &&

    c=a&&b; (c равно true, если и a, и b равны true, иначе c будет равно false)

    Здесь у нас две пары операций | и || (а также & и &&) выполняют похожие действия, однако же они не равнозначны.

    Выражение c=a|b; будет вычислять сначала оба значения - a и b и на их основе выводить результат.

    В выражении же c=a||b; вначале будет вычисляться значение a, и если оно равно true, то вычисление значения b уже смысла не имеет, так как у нас в любом случае уже c будет равно true. Значение b будет вычисляться только в том случае, если a равно false

    То же самое касается пары операций &/&&. В выражении c=a&b; будут вычисляться оба значения - a и b.

    В выражении же c=a&&b; сначала будет вычисляться значение a, и если оно равно false, то вычисление значения b уже не имеет смысла, так как значение c в любом случае равно false. Значение b будет вычисляться только в том случае, если a равно true

    Таким образом, операции || и && более удобны в вычислениях, позволяя сократить время на вычисление значения выражения и тем самым повышая производительность. А операции | и & больше подходят для выполнения поразрядных операций над числами.

12) Операции присваивания и приоритет операций
    =

    просто приравнивает одно значение другому: c=b;

    +=

    c+=b; (переменной c присваивается результат сложения c и b)

    -=

    c-=b; (переменной c присваивается результат вычитания b из c)

    *=

    c*=b; (переменной c присваивается результат произведения c и b)

    /=

    c/=b; (переменной c присваивается результат деления c на b)

    %=

    c%=b; (переменной c присваивается остаток от деления c на b)

    &=

    c&=b; (переменной c присваивается значение c&b)

    |=

    c|=b; (переменной c присваивается значение c|b)

13) Преобразования базовых типов данных
    Каждый базовый тип данных занимает определенное количество байт памяти. Это накладывает ограничение на операции, в которые вовлечены различные типы данных. Рассмотрим следующий пример:
    int a = 4;
    byte b = a; // ! Ошибка
    В данном коде мы столкнемся с ошибкой. Хотя и тип byte, и тип int представляют целые числа. Более того, значение переменной a, которое присваивается переменной типа byte, вполне укладывается в диапазон значений для типа byte (от -128 до 127). Тем не менее мы сталкиваемся с ошибкой на этапе компиляции. Поскольку в данном случае мы пытаемся присвоить некоторые данные, которые занимают 4 байта, переменной, которая занимает всего один байт.

    Тем не менее в программе может потребоваться, чтобы подобное преобразование было выполнено. В этом случае необходимо использовать операцию преобразования типов (операция ()):
    int a = 4;
    byte b = (byte)a;  // преобразование типов: от типа int к типу byte
    System.out.println(b); // 4
    Операция преобразования типов предполагает указание в скобках того типа, к которому надо преобразовать значение. Например, в случае операции (byte)a, идет преобразование данных типа int в тип byte. В итоге мы получим значение типа byte.
    Автоматически без каких-либо проблем производятся расширяющие преобразования (widening) - они расширяют представление объекта в памяти. Например:
    byte b = 7;
    int d = b;  // преобразование от byte к int
    В данном случае значение типа byte, которое занимает в памяти 1 байт, расширяется до типа int, которое занимает 4 байта.

    Расширяющие автоматические преобразования представлены следующими цепочками:

    byte -> short -> int -> long

    int -> double

    short -> float -> double

    char -> int
14) Условные конструкции
    Конструкция if/else
    int num1 = 6;
    int num2 = 8;
    if(num1>num2){
        System.out.println("Первое число больше второго");
    }
    else if(num1<num2){
        System.out.println("Первое число меньше второго");
    }
    else{
        System.out.println("Числа равны");
    }
    Конструкция switch
    Конструкция switch/case аналогична конструкции if/else, так как позволяет обработать сразу несколько условий:
    int num = 8;
    switch(num){

        case 1:
            System.out.println("число равно 1");
            break;
        case 8:
            System.out.println("число равно 8");
            num++;
            break;
        case 9:
            System.out.println("число равно 9");
            break;
        default:
            System.out.println("число не равно 1, 8, 9");
    }
    После ключевого слова switch в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями, помещенными после операторов сase. И если совпадение найдено, то будет выполняет соответствующий блок сase.

    В конце блока сase ставится оператор break, чтобы избежать выполнения других блоков.
    Если мы хотим также обработать ситуацию, когда совпадения не будет найдено, то можно добавить блок default, как в примере выше. Хотя блок default необязателен.
    Тернарная операция
    Тернарную операция имеет следующий синтаксис: [первый операнд - условие] ? [второй операнд] : [третий операнд]. Таким образом, в этой операции участвуют сразу три операнда. В зависимости от условия тернарная операция возвращает второй или третий операнд: если условие равно true, то возвращается второй операнд; если условие равно false, то третий. Например:
    int x=3;
    int y=2;
    int z = x<y? (x+y) : (x-y);
    System.out.println(z);
    Здесь результатом тернарной операции является переменная z. Сначала проверяется условие x<y. И если оно соблюдается, то z будет равно второму операнду - (x+y), иначе z будет равно третьему операнду.

15) Циклы
    Еще одним видом управляющих конструкций являются циклы. Циклы позволяют в зависимости от определенных условий выполнять определенное действие множество раз. В языке Java есть следующие виды циклов:
    for
    while
    do...while
    Цикл for
    Цикл for имеет следующее формальное определение:
    for ([инициализация счетчика]; [условие]; [изменение счетчика])
    {
        // действия
    }
    Рассмотрим стандартный цикл for:
    for (int i = 1; i < 9; i++){
        System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
    }
    Первая часть объявления цикла - int i = 1 создает и инициализирует счетчик i. Счетчик необязательно должен представлять тип int. Это может быть и любой другой числовой тип, например, float. Перед выполнением цикла значение счетчика будет равно 1. В данном случае это то же самое, что и объявление переменной.
    Вторая часть - условие, при котором будет выполняться цикл. В данном случае цикл будет выполняться, пока i не достигнет 9.
    И третья часть - приращение счетчика на единицу. Опять же нам необязательно увеличивать на единицу. Можно уменьшать: i--.
    В итоге блок цикла сработает 8 раз, пока значение i не станет равным 9. И каждый раз это значение будет увеличиваться на 1.
    Цикл do
    Цикл do сначала выполняет код цикла, а потом проверяет условие в инструкции while. И пока это условие истинно, цикл повторяется. Например:
    int j = 7;
    do{
        System.out.println(j);
        j--;
    }
    while (j > 0);
    Цикл while
    Цикл while сразу проверяет истинность некоторого условия, и если условие истинно, то код цикла выполняется:
    int j = 6;
    while (j > 0){
        System.out.println(j);
        j--;
    }
    Операторы continue и break
     Оператор break позволяет выйти из цикла в любой его момент, даже если цикл не закончил свою работу:
     Например:
     for (int i = 0; i < 10; i++){
         if (i == 5)
             break;
         System.out.println(i);
     }
     Когда счетчик станет равным 5, сработает оператор break, и цикл завершится.
     Теперь сделаем так, чтобы если число равно 5, цикл не завершался, а просто переходил к следующей итерации. Для этого используем оператор continue:
     for (int i = 0; i < 10; i++){
         if (i == 5)
             continue;
         System.out.println(i);
     }
     В этом случае, когда выполнение цикла дойдет до числа 5, программа просто пропустит это число и перейдет к следующему.

16) Массивы
    Массивы позволяют работать с наборами однотипных данных.
    Давайте начнем с шаблона создания массива.

    java
    тип_данных[] имя_переменной = new тип_данных[количество_ячеек];

    Разберемся с каждым элементом в этом шаблоне.
    1. тип_данных - здесь может быть любой: int, double, boolean, char, String.
    2. имя_переменной - по аналогии с любой переменной нужно использовать латинские буквы.
    3. new - этот оператор резервирует кусок памяти для данных, которые будут записаны в массив.
    4. количество_ячеек - массив в Java должен иметь фиксированный размер. Максимальный размер массива ограничен размером int.

    массив содержит специальное поле length, которое содержит в себе число элементов, которое было указано при объявлении массив.
    -   Заполнение массива.
    int[] nums = new int[5];
    Массив nums резервирует в памяти 5 ячеек для хранения чисел типа int. По умолчанию все элементы в нем заполняются начальными значениями.

    Для каждого типа данных он свой.

    byte, short, int, long - 0.

    float, double - 0.0

    char - '' (Пустой символ)

    boolean - false.

    String - null (Нулевая ссылка).

    Чтобы заполнить элементы массива, нужно обратиться к ним через указатель - индекс.

    Каждой ячейке массива присвоен уникальный номер, или правильно сказать - индекс. Нумерация индексов начинается с 0.
    Важно! Если в ячейке массива, в которую вы хотите положить данные, уже есть какое-то значение, то оно затрется при заполнении этой ячейки новым значением.

17) Массивы и цикл for-each
    for (тип_переменной имя_переменной : имя_массива) {
        // действия, которые мы производим с переменной который мы объявили в цикле
    }
     Пример:
     String[] numbers = {"one", "two", "three", "four", "five"};
            for (String number : numbers) {
                System.out.println(number);
            }
18) Методы
    Метод - это подпрограмма, которая содержит группу операторов.
    Чтобы выполнить метод, нужно указать имя класса и через точку имя метода.
    - Параметры
    С помощью параметров мы можем передать в методы различные данные, которые будут использоваться для вычислений. Например:
    static void sum(int x, int y){
        int z = x + y;
        System.out.println(z);
    }
    - Параметры переменной длины
      Метод может принимать параметры переменной длины одного типа. Например, нам надо передать в метод набор числел и вычислить их сумму, но мы точно не знаем, сколько именно чисел будет передано - 3, 4, 5 или больше. Параметры переменной длины позволяют решить эту задачу:
      public class Program{
          public static void main (String args[]){

              sum(1, 2, 3);           // 6
              sum(1, 2, 3, 4, 5);     // 15
              sum();                  // 0
          }
          static void sum(int ...nums){

              int result =0;
              for(int n: nums)
                  result += n;
              System.out.println(result);
          }
      }
      Троеточие перед названием параметра int ...nums указывает на то, что он будет необязательным и будет представлять массив. Мы можем передать в метод sum одно число, несколько чисел, а можем вообще не передавать никаких параметров. Причем, если мы хотим передать несколько параметров, то необязательный параметр должен указываться в конце:
      - Оператор return. Результат метода
      После оператора return указывается возвращаемое значение, которое является результатом метода. Это может быть литеральное значение, значение переменной или какого-то сложного выражения.
      В методе в качестве типа возвращаемого значения вместо void используется любой другой тип.
19) Перегрузка методов
    В программе мы можем использовать методы с одним и тем же именем, но с разными типами и/или количеством параметров. Такой механизм называется перегрузкой методов (method overloading).
    public class Program{

        public static void main(String[] args) {

            System.out.println(sum(2, 3));          // 5
            System.out.println(sum(4.5, 3.2));      // 7.7
            System.out.println(sum(4, 3, 7));       // 14
        }
        static int sum(int x, int y){

            return x + y;
        }
        static double sum(double x, double y){

            return x + y;
        }
        static int sum(int x, int y, int z){

            return x + y + z;
        }
    }
    в зависимости от типа и количества передаваемых параметров система выберет именно ту версию, которая наиболее подходит.
    При сохранении количества и типов аргументов, но изменении возвращаемого типа, программа не скомпилируется, такой способ не считается перегрузкой.

20) Введение в обработку исключений
    try...catch...finally. При возникновении исключения в блоке try управление переходит в блок catch, который может обработать данное исключение. Если такого блока не найдено, то пользователю отображается сообщение о необработанном исключении, а дальнейшее выполнение программы останавливается. И чтобы подобной остановки не произошло, и надо использовать блок try..catch.
    Конструкция try..catch также может иметь блок finally. Однако этот блок необязательный, и его можно при обработке исключений опускать. Блок finally выполняется в любом случае, возникло ли исключение в блоке try или нет.
    В Java имеется множество различных типов исключений, и мы можем разграничить их обработку, включив дополнительные блоки catch.
    - Оператор throw
    Чтобы сообщить о выполнении исключительных ситуаций в программе, можно использовать оператор throw. То есть с помощью этого оператора мы сами можем создать исключение и вызвать его в процессе выполнения.
     try{
                Scanner in = new Scanner(System.in);
                int x = in.nextInt();
                if(x>=30){
                   throw new Exception("Число х должно быть меньше 30");
               }
            }
            catch(Exception ex){

                System.out.println(ex.getMessage());
            }
21) Оболочки типов (Wrapper Classes) в Java
    Оболочки типов — это классы, которые представляют примитивные типы данных в виде объектов. Они нужны для работы с примитивами в контексте, где требуются объекты (например, коллекции, generics, или методы, принимающие Object).

    Основные оболочки типов:
    Примитивный тип	Оболочка (Wrapper Class)
    byte	Byte
    short	Short
    int	Integer
    long	Long
    float	Float
    double	Double
    char	Character
    boolean	Boolean
    Зачем нужны оболочки типов?
    Работа с коллекциями:
    Коллекции (например, ArrayList, HashMap) работают только с объектами, а не с примитивами. Оболочки позволяют хранить примитивы в коллекциях.

    java
    Copy
    List<Integer> numbers = new ArrayList<>();
    numbers.add(10); // Автоупаковка (int -> Integer)
    Использование в generics:
    Generics (например, List<T>) работают только с объектами. Оболочки позволяют использовать примитивы в generics.

    java
    Copy
    List<Integer> list = new ArrayList<>();
    Методы, принимающие Object:
    Если метод принимает Object, то примитивы нельзя передать напрямую. Оболочки решают эту проблему.

    java
    Copy
    void print(Object obj) {
        System.out.println(obj);
    }

    print(42); // Автоупаковка (int -> Integer)
    Дополнительные методы:
    Оболочки предоставляют полезные методы, например, преобразование строк в числа и обратно.

    java
    Copy
    int num = Integer.parseInt("123");
    String str = Integer.toString(123);
    Автоупаковка (Autoboxing) и распаковка (Unboxing):
    Автоупаковка — автоматическое преобразование примитива в объект оболочки.

    java
    Copy
    Integer i = 10; // int -> Integer
    Распаковка — автоматическое преобразование объекта оболочки в примитив.

    java
    Copy
    int j = i; // Integer -> int
    Пример:
    java
    Copy
    Integer a = 5; // Автоупаковка
    int b = a;     // Распаковка
    Важные моменты:
    Кэширование:
    Оболочки для небольших значений (например, Integer от -128 до 127) кэшируются, поэтому == может работать для этих значений, но не для всех.

    java
    Copy
    Integer a = 127;
    Integer b = 127;
    System.out.println(a == b); // true (кэширование)

    Integer c = 128;
    Integer d = 128;
    System.out.println(c == d); // false (разные объекты)
    NullPointerException:
    При распаковке null возникает NullPointerException.

    java
    Copy
    Integer a = null;
    int b = a; // NullPointerException
    Итог:
    Оболочки типов — это мощный инструмент для работы с примитивами в объектно-ориентированном контексте. Они используются в коллекциях, generics и других ситуациях, где требуются объекты. Автоупаковка и распаковка упрощают работу с ними, но важно помнить о возможных подводных камнях, таких как кэширование и NullPointerException.