1. Что такое "коллекция".
    Коллекции — это наборы однотипных элементов. Например, страницы в книге, яблоки в корзине или люди в очереди.
    Инструменты для работы с такими структурами в Java содержатся в Java Collections Framework. Фреймворк состоит из интерфейсов, их реализаций и утилитарных классов для работы со списками: сортировки, поиска, преобразования.

1.1. Перечислите основные методы из интерфейса java.util.Collection.
    Интерфейс Collection является обобщенным и расширяет интерфейс Iterable, поэтому все объекты коллекций можно перебирать в цикле по типу for-each.

    Среди методов интерфейса Collection можно выделить следующие:
    boolean add (E item): добавляет в коллекцию объект item. При удачном добавлении возвращает true, при неудачном - false

    boolean addAll (Collection<? extends E> col): добавляет в коллекцию все элементы из коллекции col. При удачном добавлении возвращает true, при неудачном - false

    void clear (): удаляет все элементы из коллекции

    boolean contains (Object item): возвращает true, если объект item содержится в коллекции, иначе возвращает false

    boolean isEmpty (): возвращает true, если коллекция пуста, иначе возвращает false

    Iterator<E> iterator (): возвращает объект Iterator для обхода элементов коллекции

    boolean remove (Object item): возвращает true, если объект item удачно удален из коллекции, иначе возвращается false

    boolean removeAll (Collection<?> col): удаляет все объекты коллекции col из текущей коллекции. Если текущая коллекция изменилась, возвращает true, иначе возвращается false

    boolean retainAll (Collection<?> col): удаляет все объекты из текущей коллекции, кроме тех, которые содержатся в коллекции col. Если текущая коллекция после удаления изменилась, возвращает true, иначе возвращается false

    int size (): возвращает число элементов в коллекции

    Object[] toArray (): возвращает массив, содержащий все элементы коллекции
    Вспомогательные методы.

    Обсудим вспомогательные методы, которые находят свое частое использование.

    int size() – метод возвращает размер коллекции. Т.е. фактическое количество добавленных в коллекцию элементов.

    boolean isEmpty() – метод который вернет true, если коллекция пока еще не содержит элементов.

    Для того чтобы проверить есть какой-либо элемент в коллекции можно использовать метод contains()

    boolean contains(Object o) – метод возвращает true, если переданный в метод объект содержится в коллекции.

    Чтобы очистить содержимое коллекции можно использовать метод:

    void clear() – удаляет все элементы из коллекции. После применения этого метода коллекция будет пустой.

2. Назовите преимущества использования коллекций по сравнению с массивами.
    Массивы обладают значительными недостатками. Одним из них является конечный размер массива, как следствие, необходимость следить за размером массива. Другим — индексная адресация, что не всегда удобно, т.к. ограничивает возможности добавления и удаления объектов.  Поэтому эту проблему в Java решают коллекции. Но дело не только в том, что коллекции обладают свойством автоматического расширения своего размера, но и то, что классы коллекций реализуют различные алгоритмы и структуры данных. Поэтому мы имеем хорошо оптимизированные структуры данных, которые описывают легкие способы работы с данными и при правильном выборе коллекции мы можем ускорить работу нашего приложения.

3. Какие данные могут хранить коллекции?
    Коллекции могут хранить любые ссылочные типы данных.

4. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map
    Set — это неупорядоченное множество уникальных элементов.
    Например, мешочек с бочонками для игры в лото: каждый номер от 1 до 90 встречается в нём ровно один раз, и заранее неизвестно, в каком порядке бочонки вынут при игре.

    List — упорядоченный список, в котором у каждого элемента есть индекс. Дубликаты значений допускаются.
    Например, последовательность букв в слове: буквы могут повторяться, при этом их порядок важен.

    Queue — очередь. В таком списке элементы можно добавлять только в хвост, а удалять — только из начала. Так реализуется концепция FIFO (first in, first out) — «первым пришёл — первым ушёл». Вам обязательно напомнят это правило, если попробуете пролезть без очереди в магазине:
    А ещё есть LIFO (last in, first out), то есть «последним пришёл — первым ушёл». Пример — стопка рекламных буклетов на ресепшене отеля: первыми забирают самые верхние (положенные последними). Структуру, которая реализует эту концепцию, называют стеком.

    Deque может выступать и как очередь, и как стек. Это значит, что элементы можно добавлять как в её начало, так и в конец. То же относится к удалению.

    Будет здорово, если на собеседовании вы назовёте Deque правильно: «дэк», а не «дэкью», как часто говорят.

    Map состоит из пар «ключ-значение». Ключи уникальны, а значения могут повторяться. Порядок элементов не гарантирован. Map позволяет искать объекты (значения) по ключу.

    Пример: стопка карточек с иностранными словами и их значениями. Для каждого слова (ключ) на обороте карточки есть вариант перевода (значение), а вытаскивать карточки можно в любом порядке.

    Не путайте интерфейс Collection и фреймворк Collections. Map не наследуется от интерфейса Collection, но входит в состав фреймворка Collections.

5. Назовите основные классы, которые имплементируют/реализуют интерфейсы List, Set, Map.
    + **List**: ArrayList, LinkedList
    + **Set**: HashSet, LinkedHashSat, TreeSet
    + **Map**: HashMap, LinkedHashMap, TreeMap

6. В чём отличие ArrayList от LinkedList?
    Основное отличие этих коллекций - это организация вставки и удаления элементов.
    ArrayList реализован внутри в виде обычного массива. Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. Зато в нем быстро реализованы взятие и изменение элемента – операции get, set, так как в них мы просто обращаемся к соответствующему элементу массива.
    LinkedList реализован внутри по-другому. Он реализован в виде связного списка: набора отдельных элементов, каждый из которых хранит ссылку на следующий и предыдущий элементы. Чтобы вставить элемент в середину такого списка, достаточно поменять ссылки его будущих соседей. А вот чтобы получить элемент с номером 130, нужно пройтись последовательно по всем объектам от 0 до 130. Другими словами операции set и get тут реализованы очень медленно. Посмотри на таблицу:

    Описание	            Операция	    ArrayList	LinkedList
    Взятие элемента	        get	            Быстро	Медленно
    Присваивание элемента	set	            Быстро	Медленно
    Добавление элемента	    add	            Быстро	Быстро
    Вставка элемента	    add(i, value)	Медленно	Быстро
    Удаление элемента	    remove	        Медленно	Быстро

    Если необходимо вставлять (или удалять) в середину коллекции много элементов, то лучше использовать LinkedList. Во всех остальных случаях – ArrayList.

    LinkedList требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка, тогда как в ArrayList элементы просто идут по порядку

7. В чём отличие HashSet от TreeSet?
    + **HashSet** хранит данные в произвольном порядке (хранит свои значения как ключи HashMap).
    + **TreeSet** хранит данные в отсортированном виде (бинарное дерево).

8. В чём отличие Set от Map?
     Set – это множество – куча ненумерованных объектов. Главная особенность Set – в нем только уникальные объекты, т.е. они все разныe.
     Map – это множество пар. То же множество, но не одиноких элементов, а пар: ключ-значение. Единственное ограничение: первый объект в паре, называемый ключом, должен быть уникальным. В Map не может содержаться две пары с одинаковыми ключами.

9. Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?
    Порядок задается либо естественным следованием элементов (Natural order),
    либо объектом, реализующим интерфейс сравнения Comparator.
    Если объекты коллекции поддерживают интерфейс Comparable, то через Collections.sort(collection);
    Если нет, то у коллекции вызвать метод sort и передать ему Comparator в качестве аргумента.
    через Comparable или Comparator.

10. Чем отличается Comparable от Comparator?
    Comparable - имплементится самим классом, когда нужен натуральный порядок сортировки. Пример - класс String. Comparator - имплементится другими классами. Дает возможность отделить реализацию сравнения от класса и сделать несколько реализаций сравнения по разным параметрам для одного класса.

11. Что такое сортировка по принципу Natural Order?
    Некоторые классы из коробки реализуют естественный порядок для сортировки.
    + Это строки - лексикографический (по алфавиту),
    + числа - числовой, знаковый или без (больше меньше),
    + дата - хронологичский (по датам),
    + файл - лексикографический по имени пути
    + boolean - false < true

12. Что такое equals и hashcode?
    Методы, необходимые для определения равенства объектов.
    Хэш-код – это целое число, которое является уникальным идентификатором содержимого объекта. От сюда вывод – у
     каждого объекта, с разными данными, свое уникальное число, с помощью которого мы можем судить о равенстве или неравенстве.
    Метод equals () в Java используется для проверки равенства двух объектов. Он наследуется из класса Object и может быть переопределен в пользовательских классах. Метод equals () проверяет, являются ли два объекта равными. По умолчанию метод equals () сравнивает два объекта по ссылке, то есть возвращает true только в том случае, если ссылки указывают на один и тот же объект.

13. Какие есть способы перебора всех элементов List?
    - fori
    - while
    - iterator
    - listIterator
    - forEach

14. Расскажите о методах Map.
    - void clear(): очищает коллекцию
    - boolean containsKey(Object k): возвращает true, если коллекция содержит ключ k
    - boolean containsValue(Object v): возвращает true, если коллекция содержит значение v
    - Set<Map.Entry<K, V>> entrySet(): возвращает набор элементов коллекции. Все элементы представляют объект Map.Entry
    - boolean isEmpty: возвращает true, если коллекция пуста
    - V get(Object k): возвращает значение объекта, ключ которого равен k. Если такого элемента не окажется, то возвращается значение null
    - V put(K k, V v): помещает в коллекцию новый объект с ключом k и значением v. Если в коллекции уже есть объект с подобным ключом, то он перезаписывается. После добавления возвращает предыдущее значение для ключа k, если он уже был в коллекции. Если же ключа еще не было в коллекции, то возвращается значение null
    - V putIfAbsent(K k, V v): помещает в коллекцию новый объект с ключом k и значением v, если в коллекции еще нет элемента с подобным ключом.
    - Set<K> keySet(): возвращает набор всех ключей отображения
    - Collection<V> values(): возвращает набор всех значений отображения
    - void putAll(Map<? extends K, ? extends V> map): добавляет в коллекцию все объекты из отображения map
    - V remove(Object k): удаляет объект с ключом k
    - int size(): возвращает количество элементов коллекции
    - Map.Entry<K, V>.

      Обобщенный интерфейс Map.Entry<K, V> представляет объект с ключом типа K и значением типа V и определяет следующие методы:

      boolean equals(Object obj): возвращает true, если объект obj, представляющий интерфейс Map.Entry, идентичен текущему

      K getKey(): возвращает ключ объекта отображения

      V getValue(): возвращает значение объекта отображения

      V setValue(V v): устанавливает для текущего объекта значение v

      int hashCode(): возвращает хеш-код данного объекта

15. Расскажите, какие классы реализовывают интерфейс Map?
    HashMap, TreeMap

16. Расскажите о методах map.keySet и map.entrySet? Что такое Entry?
    В коллекции HashMap есть вспомогательный класс для хранения пары элементов. Выглядит он примерно так:
    У элементов класса HashMap нет порядкового номера, поэтому цикл со счетчиком тут не подойдет. Зато мы можем получить множество ключей с помощью метода keySet(), а как пройтись по множеству вы уже знаете:
    Результат вызова метода entrySet() у объекта типа HashMap<ТКлюч, ТЗначение> будет иметь тип Set<Entry<ТКлюч, Значение>>:
    Set<Entry<Ключ, Значение>> имя = map.entrySet();
    Entry ->
    class Entry<KeyType, ValueType>
    {
       private KeyType key;
       private ValueType value;
    }

17. Что будет если вызвать метод map.put несколько раз с одинаковым ключом?
        Если вы вызываете put () более одного раза с одним и тем же ключом, последнее заменяет существующее значение для данного ключа.

18. Как реализован цикл foreach?
    цикл for-each внутри использует механизм итератора.

19. В чем разница между Iterator и Iterable?
    Iterable (какое) - итерируемое. То по чему можно итерироваться. Имплементируется классом, по которому нужно будет итерироваться.
    Iterator (кто/что) - инструмент итерирования по коллекции. Итератор это отдельный класс, как правило вложенный в итерируемый класс, который задает логику итерации по итерируемому. И, естественно, имплементирует интерфейс Iterable.

20. Как происходит удаление элементов из ArrayList?
21. Как происходит удаление элементов из LinkedList?
22. Что такое автоупаковка и распаковка? Зачем они нужны?
    Примитивные типы не являются ссылочными типами (объектами), поэтому если нам требуется объект примитивного типа, его значение должно быть упаковано в соответствующий класс-обёртку. Например, int в Integer или long в Long. Начиная с Java 5 такие преобразования выполняются компилятором автоматически и называются автоупаковкой и распаковкой.

    Автоупаковка происходит в следующих случаях:

    1) Если значение примитивного типа присваивается типу соответствующего класса-обёртки. Например:

    Integer b = 2;

23. В каком случае при работе с упакованными значениями может возникнуть проблема с производительностью?
    Классы-обертки являются неизменяемыми, поэтому упакованное значение невозможно изменить. Следующий код будет приводить в постоянному пересозданию новых объектов и чрезмерному расходу памяти:

    Integer sum = 0;
    for (int i = 128; i < 300; i++) {
        sum += i;
    }
    System.out.println(sum);
    При перезаписи переменной sum каждый раз будет создаваться новый объект в памяти

24. Опишите недостатки и преимущества в использовании примитивных типов и классов-оберток.
    - При работе с примитивными типами повышается производительность, так как на упаковку значения в обёртку уходит дополнительное время.

    - Примитивные типы занимают меньше места в памяти.

    - Если в программе работа идет с объектами, а не со значениями, то работать с примитивными типами будет нельзя, понадобится упаковка.

    - Обёртки - это такие же классы со своими методами, как и любые остальные, которые мы рассматривали. Поэтому работа со значением в виде объекта даёт преимущества в виде возможности применения методов этих классов. (Например, для Integer это parseInt(), valueOf(), compareTo() и т.д.).

25. Что такое очередь? Расскажите принцип работы и для чего она используется.
    Структура данных, которая в программировании называется очередью, представляет из себя хранилище однотипных элементов, в котором первым будет извлекаться тот элемент, который был туда и вставлен первым. Такой способ организации хранения данных называется FIFO, по первым буквам фразы, описывающей этот способ хранения – First-In-First-Out).
    Очередь – очень удобный инструмент, который используется для моделирования реальных ситуаций ожидания клиентов в банке, вылета самолетов или передачи данных по Интернету.
    1. Очередь используется для вставки элементов в конец очереди и удаления из начала очереди. Она следует концепции FIFO.

    2. В Java интерфейс Queue поддерживает все методы интерфейса Collection, включая вставку, удаление и т.д.

    3. LinkedList , ArrayBlockingQueue и PriorityQueue — наиболее часто используемые реализации интерфейса Queue.

    4. Очереди, доступные в пакете java.util, являются неограниченными очередями.

    5. Очереди, доступные в пакете java.util.concurrent, являются ограниченными очередями.

26. Расскажите про интерфейсы Queue, Deque и их иерархию.
    Ранее мы уже рассмотрели интерфейс Queue, который в свою очередь расширяет интерфейс Collection. Как мы помним, такая очередь позволяет поместить элементы в один конец очереди, а извлекать их – из другого. Поэтому такие очереди называются односторонними.
    В текущей задаче мы познакомимся с интерфейсом, который расширяет интерфейс Queue – это интерфейс Deque.
    Этот интерфейс также является очередью, но ее отличительной особенностью то, что эта очередь является двухсторонней, т.е. она поддерживает удаление и добавление элементов с обоих концов очереди. Таким образом, в отличие от Queue, здесь также можно организовать способ хранения элементов по принципу LIFO (сокращение по первой букве от описания этого принципа на английском языке Last In First Out – последний пришел, первый вышел). Такую структуру данных в программировании называют стеком. Пример аналогии из жизни – стопка тетрадей на проверку у учителя, учитель проверяет их по порядку и та тетрадь, которая была положена в эту стопку первой будет проверена последней.
    1. В очередь Deque элементы можно добавлять, удалять и извлекать с обоих ее сторон. Она следует как принципу FIFO, так и при правильной организации можно получить поведение по принципу LIFO.

    2. В Java интерфейс Deque поддерживает все методы интерфейса Queue, Collection, включая вставку, удаление и т.д.

    3. Необходимо быть предельно аккуратными при использовании методов, которые при своей работе генерируют непроверяемое исключение. Предпочитайте использовать методы poll(), pollFirst(), pollLast, peekFirst(), peekLast(), peek().

    4. Наиболее часто используемой реализацией интерфейса Deque является LinkedList.

27. В чем отличие метода poll() от remove()?
     Методы remove() и poll() – методы позволяют удалить верхний (первый) элемент из очереди и возвращают ее.
     Методы remove() и poll() отличаются лишь поведением, когда очередь пустая: метод remove() генерирует исключение, а метод poll() возвращает null.

28. В чем отличие метода element() от peek()?
     Методы element() и peek() возвращают (но не удаляют) верхушку очереди.
      В данном случае если метод element() вызывать на пустой очереди, то будет сгенерировано исключение NoSuchElementException.
      Если заменить на вызов метода peek(), то в консоль будет выведен null.

30. Перечислите наиболее часто используемые реализации интерфейса Queue.
    LinkedList , ArrayBlockingQueue и PriorityQueue — наиболее часто используемые реализации интерфейса Queue.

31. Что такое ограниченные и неограниченные очереди?
    Ограниченные очереди-это очереди, которые ограничены емкостью, что означает, что нам нужно указать максимальный размер очереди на момент создания. Например, ArrayBlockingQueue (см. Предыдущий пример).
    Неограниченные очереди-это очереди, которые НЕ ограничены емкостью, что означает, что мы не должны указывать размер очереди.

32. Что такой односторонние и двусторонние очереди?
    Односторонняя очередь - очередь основана на принципе — FIFO (“first in — first out”, “первым вошел — первым вышел”).
    Двусторонняя очередь.
    Она расширяет функционал обычной очереди, позволяя добавлять элементы на оба края (в начало и конец очереди) и забирать элементы с обоих краев очереди.

35. Назовите самую распространенную реализацию Deque.
    Наиболее часто используемой реализацией интерфейса Deque является LinkedList.

