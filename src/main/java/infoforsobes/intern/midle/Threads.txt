https://javastudy.ru/interview/concurrent/ - Собеседование по Java — многопоточность (вопросы и ответы)
https://habr.com/ru/companies/otus/articles/353414/ - очень крутая статья Разбор основных концепций параллелизма

1)  Многозадачность и параллелизм.
https://habr.com/ru/articles/337528/

2)  Многопоточность: что делают методы класса Thread
https://javarush.com/groups/posts/1993-mnogopotochnostjh-chto-delajut-metodih-klassa-thread
2.1) Метод Thread.start()
Начнем с повторения. Как ты наверняка помнишь, создать поток можно унаследовав свой класс от класса Thread и переопределив в нем метод run().

Но сам он, конечно, не запустится. Для этого у нашего объекта вызываем метод start().

Обрати внимание: чтобы запустить поток, необходимо вызвать специальный метод start(), а не метод run()! Эту ошибку легко допустить, особенно в начале изучения многопоточности.

Дело в том, что прямой вызов метода run() не имеет отношения к многопоточности. В этом случае программа будет выполнена в главном потоке — том, в котором выполняется метод main(). Он просто последовательно выведет 10 строк на консоль и все. Никакие 10 потоков не запустятся.

2.2)    Метод sleep() принимает в качестве параметра число миллисекунд, то есть то время, на которое необходимо «усыпить» поток.
Обрати внимание: метод sleep() — статический: он усыпляет текущий поток. То есть тот, который работает в данный момент.

Еще один важный нюанс: поток в состоянии сна можно прервать. В таком случае в программе возникнет исключение InterruptedException. Мы рассмотрим пример ниже.

Кстати, а что произойдет после того, как поток «проснется»? Продолжит ли он сразу же свое выполнение с того места, где закончил? Нет.

После того, как поток «просыпается» — когда заканчивается время, переданное в качестве аргумента в Thread.sleep(), — он переходит в состояние runnable, «работоспособный». Однако это не значит, что планировщик потоков запустит именно его. Вполне возможно, он отдаст предпочтение какому-то другому «неспящему» потоку, а наш «свежепроснувшийся» продолжит работу чуть позже.

Обязательно запомни: «проснулся — не значит продолжил работать в ту же секунду»!

2.3)    Метод Thread.join()
Метод join() можно использовать, чтобы гарантировать последовательность выполнения потоков.
Главная логика заключена в классе Main. Посмотри на комментарии: с помощью метода join() мы успешно управляем последовательностью выполнения потоков.
Здесь же мы с помощью метода гарантировали, что сначала будет запущен и выполнен поток t1, затем — t2, и только после них — главный поток выполнения программы.

2.4)    Метод Thread.interrupt()
Что произойдет, если у потока вызвать метод interrupt()?

Есть 2 варианта:

Если объект находился в этот момент в состоянии ожидания, например, join или sleep, ожидание будет прервано, и программа выбросит InterruptedException.
Если же поток в этот момент был в работоспособном состоянии, у объекта будет установлен boolean-флаг interrupted.

Но проверить объект на значение этого флага и корректно завершить работу мы должны будем самостоятельно! Для этого в классе Thread есть специальный метод — boolean isInterrupted().

https://youtu.be/zxZ0BXlTys0?si=V6dKtn11lxp6cST0

3)  Что такое «потоки-демоны»
Потоки-демоны работают в фоновом режиме вместе с программой, но не являются неотъемлемой частью программы. Если какой-либо процесс может выполняться на фоне работы основных потоков выполнения и его деятельность заключается в обслуживании основных потоков приложения, то такой процесс может быть запущен как поток-демон с помощью метода setDaemon(boolean value), вызванного у потока до его запуска. Метод boolean isDaemon() позволяет определить, является ли указанный поток демоном или нет. Базовое свойство потоков-демонов заключается в возможности основного потока приложения завершить выполнение потока-демона (в отличие от обычных потоков) с окончанием кода метода main(), не обращая внимания на то, что поток-демон еще работает.

4)  Состояние гонки (Race condition)
https://habr.com/ru/articles/764234/
Race condition (состояние гонки) - это ситуация, при которой несколько потоков (или процессов) одновременно пытаются выполнить операции чтения или записи к общим ресурсам без должной синхронизации.
Как правило, состояние гонки протекают по определенной схеме:

Критическая секция: Это участок кода, в котором происходит обращение к общим ресурсам и их модификация.

Синхронизация: Отсутствие надлежащих механизмов синхронизации может позволить нескольким процессам одновременно войти в критическую секцию.

Непредсказуемый результат: Из-за одновременного выполнения конечное состояние общего ресурса становится неопределенным.

5) Понятие Синхронизация и Монитор
Критическая секция
Этот метод подходит вам, если:

Параллельные потоки работают с общим ресурсом;
требуется синхронизация между потоками, а не процессами;
Этот метод синхронизации называется синхронизацией ресурсов («синхронизация «открыть — закрыть»). Идея этого метода заключается в том, что каждый объект в Java имеет связанный с ним монитор. Монитор — это своего рода инструмент для управления доступом к объекту.

Синхронизированный оператор используется для создания критической секции. Когда выполнение кода достигает синхронизированного оператора, монитор объекта блокируется. В момент блокировки монопольный доступ к блоку кода имеет только один поток, выполнивший блокировку. После завершения работы блока кода объектный монитор освобождается и становится доступным для других потоков.

Когда монитор освобождается, он захватывается другим потоком, а все остальные потоки продолжают ждать его освобождения.

6)  Volatile и Atomic
Atomicity (атомарность)	Атомарная операция — это операция, которая выполняется полностью или не выполняется совсем, частичное выполнение невозможно.
Visibility (видимость)	Условия, при которых один поток видит изменения, сделанные другим потоком

Ключевое слово volatile и классы из пакета java.util.concurrent.atomic, такие как AtomicInteger, AtomicLong и другие, оба используются для обеспечения потокобезопасности в многопоточной среде, но есть некоторые различия:

Вид переменных: volatile может применяться только к переменным, в то время как классы из пакета java.util.concurrent.atomic предоставляют атомарные операции для определенных типов данных, таких как целые числа (AtomicInteger, AtomicLong), булевы значения (AtomicBoolean), ссылки (AtomicReference) и т.д.

Атомарность операций: Классы из пакета java.util.concurrent.atomic предоставляют атомарные операции чтения и записи для соответствующих типов данных. Это означает, что операции чтения и записи этих переменных являются атомарными и гарантированно безопасны в многопоточной среде. С другой стороны, ключевое слово volatile обеспечивает только видимость изменений значения переменной между потоками, но не обеспечивает атомарности операций.

Работа с состоянием: Классы из пакета java.util.concurrent.atomic позволяют выполнять атомарные операции над переменными, такие как инкремент, декремент, обновление и т.д. Они предоставляют методы, которые гарантируют атомарность операций над переменными. С другой стороны, volatile применяется к переменной целиком и обеспечивает видимость ее изменений между потоками, но не предоставляет специфических атомарных операций.

Область применения: volatile наиболее полезно, когда переменная используется для синхронизации состояния или флага, например, для сигнализации остановки потока. Классы из пакета java.util.concurrent.atomic особенно полезны, когда требуется выполнение атомарных операций над числовыми значениями или ссылками в многопоточной среде.

В целом, использование volatile и классов из пакета java.util.concurrent.atomic зависит от конкретной ситуации и требований вашей программы. Если вам нужно обеспечить только видимость изменений переменной, то volatile может быть хорошим выбором. Если вам нужно обеспечить атомарность операций над переменными или выполнение сложных операций, вы можете воспользоваться классами из пакета java.util.concurrent.atomic.

7)   CountDownLatch
CountDownLatch - это синхронизационный механизм, предоставляемый Java в пакете java.util.concurrent, который позволяет одному или нескольким потокам ждать, пока другие потоки завершат выполнение своих задач.

Принцип работы CountDownLatch заключается в том, что вы создаете объект CountDownLatch с определенным счетчиком, который инициализируется при создании. Затем один или несколько потоков могут уменьшать этот счетчик, вызывая метод countDown(). Другие потоки могут ждать, пока счетчик не станет равным нулю, вызывая метод await().

8)   ExecutorService
https://habr.com/ru/articles/554608/
https://java-online.ru/concurrent-executor.xhtml
В многопоточный пакет concurrent для управления потоками включено средство, называемое сервисом исполнения ExecutorService. Данное средство служит альтернативой классу Thread, предназначенному для управления потоками. В основу сервиса исполнения положен интерфейс Executor, в котором определен один метод :

void execute(Runnable thread);
При вызове метода execute исполняется поток thread. То есть, метод execute запускает указанный поток на исполнение. Следующий код показывает, как вместо обычного старта потока Thread.start() можно запустить поток с использованием сервиса исполнения :

// Вместо следующего кода
new Thread(new RunnableTask()).start();

// можно использовать
ExecutorService executor;
. . .
executor.execute(new CallableSample1());
Future<String> f1 = executor.submit(new CallableSample2());
При запуске задач с помощью Executor пакета java.util.concurrent не требуется прибегать к низкоуровневой поточной функциональности класса Thread, достаточно создать объект типа ExecutorService с нужными свойствами и передать ему на исполнение задачу типа Callable. Впоследствии можно легко просмотреть результат выполнения этой задачи с помощью объекта Future.

Интерфейс ExecutorService расширяет свойства Executor, дополняя его методами управления исполнением и контроля. Так в интерфейс ExecutorService включен метод shutdown(), позволяющий останавливать все потоки исполнения, находящиеся под управлением экземпляра ExecutorService. Также в интерфейсе ExecutorService определяются методы, которые запускают потоки исполнения FutureTask, возвращающие результаты и позволяющие определять статус остановки.

9)  ThreadFactory
Говоря о создании и пересоздании потоков, мы не можем не упомянуть о ThreadFactory.

ThreadFactory — это объект, который создает новые потоки по требованию.

Мы можем создать свою фабрику создания потоков и передать ее экземпляр в метод Executors.newSingleThreadExecutor(ThreadFactory threadFactory).

ExecutorService executorService = Executors.newSingleThreadExecutor(new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                return new Thread(r, "MyThread");
            }
        });
Переопределили метод создания нового потока, передав в конструктор имя.
ExecutorService executorService = Executors.newSingleThreadExecutor(new ThreadFactory() {
            @Override
            public Thread newThread(Runnable r) {
                Thread thread = new Thread(r, "MyThread");
                thread.setPriority(Thread.MAX_PRIORITY);
                return thread;
            }
        });
Поменяли имя и приоритет для создаваемого потока.
Таким образом выяснили, что есть 2 перегруженных метода Executors.newSingleThreadExecutor. Один — без параметров, второй — с параметром типа ThreadFactory.

С помощью фабрики создания потоков ThreadFactory можно делать разные настройки создаваемым потокам, например, – выставить приоритеты, использовать подклассы потоков, добавить поток UncaughtExceptionHandler и так далее.

10) Блокирующие очереди пакета concurrent
https://java-online.ru/concurrent-queue-block.xhtml  Блокирующие очереди пакета concurrent

    Пакет java.util.concurrent включает классы для формирования блокирующих очередей с поддержкой многопоточности. Блокирующие очереди используются в тех случаях, когда нужно выполнить (проверить выполненение) какие-либо условия для продолжения потоками своей работы. Блокирующие очереди могут реализовывать интерфейсы BlockingQueue, BlockingDeque, TransferQueue. В пакете java.util.concurrent имеются следующие реализации блокирующих очередей :

Интерфейс BlockingQueue
Интерфейс BlockingQueue определяет блокирующую очередь, наследующую свойства интерфейса Queue, в которой элементы хранятся в порядке «первый пришел, первый вышел» (FIFO – first in, first out). Реализация данного интерфейса обеспечивает блокировку потока в двух случаях :

при попытке получения элемента из пустой очереди;
при попытке размещения элемента в полной очереди.
Когда поток пытается получить элемент из пустой очереди, то он переводится в состояние ожидания до тех пор, пока какой-либо другой поток не разместит элемент в очереди. Аналогично при попытке положить элемент в полную очередь; поток ставится в ожидание до тех пор, пока другой поток не заберет элемент из очереди и, таким образом, не освободит место в ней. Естественно, понятие "полная очередь" подразумевает ограничение размера очереди.

BlockingQueue изящно решает проблему передачи собранных одним потоком элементов для обработки в другой поток без явных хлопот о проблемах синхронизации.

11) Методы wait и notify
Иногда при взаимодействии потоков встает вопрос об извещении одних потоков о действиях других. Например, действия одного потока зависят от результата действий другого потока, и надо как-то известить один поток, что второй поток произвел некую работу. И для подобных ситуаций у класса Object определено ряд методов:

wait(): освобождает монитор и переводит вызывающий поток в состояние ожидания до тех пор, пока другой поток не вызовет метод notify()

notify(): продолжает работу потока, у которого ранее был вызван метод wait()

notifyAll(): возобновляет работу всех потоков, у которых ранее был вызван метод wait()

Все эти методы вызываются только из синхронизированного контекста - синхронизированного блока или метода.

12) Потокобезопасные concurrent коллекции
    Пакет java.util.concurrent включает несколько потокобезопасных коллекций :

    • ConcurrentHashMap	коллекция типа HashMap, реализующая интерфейс ConcurrentMap;
    • CopyOnWriteArrayList	коллекция типа ArrayList с алгоритмом CopyOnWrite;
    • CopyOnWriteArraySet	реализация интерфейса Set, использующая за основу CopyOnWriteArrayList;

13) Deadlock (взаимная блокировка) - это ситуация, которая возникает в многопоточных приложениях, когда два или более потоков заблокированы и ждут друг друга, чтобы завершить выполнение определенных действий. В результате ни один из этих потоков не может продолжить свое выполнение, что приводит к задержке работы всего приложения












