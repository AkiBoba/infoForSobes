1. Что такое "коллекция".
    Коллекции — это наборы однотипных элементов. Например, страницы в книге, яблоки в корзине или люди в очереди.
    Инструменты для работы с такими структурами в Java содержатся в Java Collections Framework. Фреймворк состоит из интерфейсов, их реализаций и утилитарных классов для работы со списками: сортировки, поиска, преобразования.

1.1. Перечислите основные методы из интерфейса java.util.Collection.
    Интерфейс Collection является обобщенным и расширяет интерфейс Iterable, поэтому все объекты коллекций можно перебирать в цикле по типу for-each.

    Среди методов интерфейса Collection можно выделить следующие:
    boolean add (E item): добавляет в коллекцию объект item. При удачном добавлении возвращает true, при неудачном - false

    boolean addAll (Collection<? extends E> col): добавляет в коллекцию все элементы из коллекции col. При удачном добавлении возвращает true, при неудачном - false

    void clear (): удаляет все элементы из коллекции

    boolean contains (Object item): возвращает true, если объект item содержится в коллекции, иначе возвращает false

    boolean isEmpty (): возвращает true, если коллекция пуста, иначе возвращает false

    Iterator<E> iterator (): возвращает объект Iterator для обхода элементов коллекции

    boolean remove (Object item): возвращает true, если объект item удачно удален из коллекции, иначе возвращается false

    boolean removeAll (Collection<?> col): удаляет все объекты коллекции col из текущей коллекции. Если текущая коллекция изменилась, возвращает true, иначе возвращается false

    boolean retainAll (Collection<?> col): удаляет все объекты из текущей коллекции, кроме тех, которые содержатся в коллекции col. Если текущая коллекция после удаления изменилась, возвращает true, иначе возвращается false

    int size (): возвращает число элементов в коллекции

    Object[] toArray (): возвращает массив, содержащий все элементы коллекции
    Вспомогательные методы.

    Обсудим вспомогательные методы, которые находят свое частое использование.

    int size() – метод возвращает размер коллекции. Т.е. фактическое количество добавленных в коллекцию элементов.

    boolean isEmpty() – метод который вернет true, если коллекция пока еще не содержит элементов.

    Для того чтобы проверить есть какой-либо элемент в коллекции можно использовать метод contains()

    boolean contains(Object o) – метод возвращает true, если переданный в метод объект содержится в коллекции.

    Чтобы очистить содержимое коллекции можно использовать метод:

    void clear() – удаляет все элементы из коллекции. После применения этого метода коллекция будет пустой.

2. Назовите преимущества использования коллекций по сравнению с массивами.
    Массивы обладают значительными недостатками. Одним из них является конечный размер массива, как следствие, необходимость следить за размером массива. Другим — индексная адресация, что не всегда удобно, т.к. ограничивает возможности добавления и удаления объектов.  Поэтому эту проблему в Java решают коллекции. Но дело не только в том, что коллекции обладают свойством автоматического расширения своего размера, но и то, что классы коллекций реализуют различные алгоритмы и структуры данных. Поэтому мы имеем хорошо оптимизированные структуры данных, которые описывают легкие способы работы с данными и при правильном выборе коллекции мы можем ускорить работу нашего приложения.

3. Какие данные могут хранить коллекции?
    Коллекции могут хранить любые ссылочные типы данных.

4. Какие есть типы коллекций? Как они характеризуются? Расскажите про иерархию коллекций List, Set, Map
    Set — это неупорядоченное множество уникальных элементов.

    Например, мешочек с бочонками для игры в лото: каждый номер от 1 до 90 встречается в нём ровно один раз, и заранее неизвестно, в каком порядке бочонки вынут при игре.

    List — упорядоченный список, в котором у каждого элемента есть индекс. Дубликаты значений допускаются.

    Например, последовательность букв в слове: буквы могут повторяться, при этом их порядок важен.

    Queue — очередь. В таком списке элементы можно добавлять только в хвост, а удалять — только из начала. Так реализуется концепция FIFO (first in, first out) — «первым пришёл — первым ушёл». Вам обязательно напомнят это правило, если попробуете пролезть без очереди в магазине:
    А ещё есть LIFO (last in, first out), то есть «последним пришёл — первым ушёл». Пример — стопка рекламных буклетов на ресепшене отеля: первыми забирают самые верхние (положенные последними). Структуру, которая реализует эту концепцию, называют стеком.

    Deque может выступать и как очередь, и как стек. Это значит, что элементы можно добавлять как в её начало, так и в конец. То же относится к удалению.

    Будет здорово, если на собеседовании вы назовёте Deque правильно: «дэк», а не «дэкью», как часто говорят.

    Map состоит из пар «ключ-значение». Ключи уникальны, а значения могут повторяться. Порядок элементов не гарантирован. Map позволяет искать объекты (значения) по ключу.

    Пример: стопка карточек с иностранными словами и их значениями. Для каждого слова (ключ) на обороте карточки есть вариант перевода (значение), а вытаскивать карточки можно в любом порядке.

    Не путайте интерфейс Collection и фреймворк Collections. Map не наследуется от интерфейса Collection, но входит в состав фреймворка Collections.

5. Назовите основные классы, которые имплементируют/реализуют интерфейсы List, Set, Map.
    + **List**: ArrayList, LinkedList
    + **Set**: HashSet, LinkedHashSat, TreeSet
    + **Map**: HashMap, LinkedHashMap, TreeMap

6. В чём отличие ArrayList от LinkedList?
    Основное отличие этих коллекций - это организация вставки и удаления элементов.
    ArrayList реализован внутри в виде обычного массива. Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. Зато в нем быстро реализованы взятие и изменение элемента – операции get, set, так как в них мы просто обращаемся к соответствующему элементу массива.
    LinkedList реализован внутри по-другому. Он реализован в виде связного списка: набора отдельных элементов, каждый из которых хранит ссылку на следующий и предыдущий элементы. Чтобы вставить элемент в середину такого списка, достаточно поменять ссылки его будущих соседей. А вот чтобы получить элемент с номером 130, нужно пройтись последовательно по всем объектам от 0 до 130. Другими словами операции set и get тут реализованы очень медленно. Посмотри на таблицу:

    Описание	            Операция	    ArrayList	LinkedList
    Взятие элемента	        get	            Быстро	Медленно
    Присваивание элемента	set	            Быстро	Медленно
    Добавление элемента	    add	            Быстро	Быстро
    Вставка элемента	    add(i, value)	Медленно	Быстро
    Удаление элемента	    remove	        Медленно	Быстро

    Если необходимо вставлять (или удалять) в середину коллекции много элементов, то лучше использовать LinkedList. Во всех остальных случаях – ArrayList.

    LinkedList требует больше памяти для хранения такого же количества элементов, потому что кроме самого элемента хранятся еще указатели на следующий и предыдущий элементы списка, тогда как в ArrayList элементы просто идут по порядку
