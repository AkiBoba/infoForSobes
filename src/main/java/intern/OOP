
1) [Что такое ООП?](#что-такое-ооп)
* Объектно-ориентированное программирование (ООП) - это парадигма (методология) программирования, в которой приложения состоят из взаимодействующих между собой объектов.
* Объект - это центр ООП. Нас окружают объекты, мы сами объекты. Объекты позволяют абстрагироваться или отвлечься от внутреннего устройства объекта и сфокусироваться на свойствах и возможностях этого объекта.
* Каждый объект - это отдельная сущность со своим набором данных и инструкциями к действию, то есть это элемент системы с присущими ему свойствами.
* Также объекты можно объединять в комплексные объекты, а их в свою очередь в целые системы. Это позволяет выполнять масштабные проекты.
* Класс - это описание объекта. Когда нам нужно, мы просим виртуальную машину сделать для нас объект по описанию, который мы делаем в классе.
* Основные достоинства ООП относительно других парадигм программирования - быстрое расширение программы путем добавления новых элементов, хорошая читаемость кода, возможность повторного использования написанного кода и относительная простота написания кода. Эти факторы в совокупности помогают создавать, расширять и поддерживать программы большого размера. Основными недостатками ООП являются увеличенное потребление памяти за счет использования объектов, а также меньшая производительность, так как внутренняя реализация предоставляемых языком средств тоже требует затрат.

2) [Базовые концепции ООП?](#базовые-концепции-ооп)
* Инкапсуляция - сокрытие реализации;
* Наследование - создание новой сущности на базе уже существующей;
* Полиморфизм - возможность иметь разные формы для одной и той же сущности;
* Абстракция - набор общих характеристик.

3) [Укажите из каких элементов состоит класс.](#укажите-из-каких-элементов-состоит-класс)
Класс состоит из полей (атрибуты, свойства или переменные) и методов (функции для работы с полями). Поля и методы называются членами класса. Поле (атрибут) класса - характеристика объекта, содержащая его состояние. Например, для коробки это может быть высота, ширина, длина, материал. Класс - ссылочный тип данных. Это шаблон для создания объекта, а объект - это экземпляр класса.
Метод класса в объектно-ориентированном программировании — это функция или процедура, принадлежащая какому-либо классу или объекту.

Как и процедура в процедурном программировании, метод состоит из некоторого количества операторов для выполнения определенного действия и может иметь набор входных параметров.

Различают простые методы и статические методы :

простые методы имеют доступ к данным объекта конкретного экземпляра (данного класса);
статические методы не имеют доступа к данным объекта, и для их использования не нужно создавать экземпляры (данного класса).
Методы предоставляют интерфейс, при помощи которого осуществляется доступ к данным объекта некоторого класса, тем самым, обеспечивая инкапсуляцию данных.

Кроме имени и тела (кода) у метода есть ряд других характеристик:

набор модификаторов;
тип возвращаемого значения;
набор аргументов (параметров).

4) [Что такое конструктор?](#что-такое-конструктор)
Конструктор - это специальный метод, который вызывается при создании нового объекта.
По сути конструктор нужен для автоматической инициализации переменных.
Конструкторы вызываются при создании нового объекта нашего класса. Имя конструктора совпадает с именем класса, в том числе и соблюдая регистр, при этом синтаксически конструктор похож на метод без возвращаемого значения.
Computer computer = new Computer();
То, что стоит после оператора new и есть вызов конструктора класса Computer, и в данном случае после имени класса мы ставим круглые скобки. Это подчеркивает, что конструктор - это метод. Однако сразу возникает вопрос – что мы можем вызывать, если никаких конструкторов в классе у нас нет. Связано это со следующим:
- если в классе не определенно ни одного конструктора, то для этого класса создается конструктор без параметров, или как его еще называют – дефолтный конструктор или конструктор по умолчанию.
Для создания объекта Computer мы используем выражение new Computer(). При этом оператор new выделяет память для нашего объекта computer типа Computer. На следующем этапе происходит вызов конструктора по умолчанию, который не принимает никаких параметров. После выполнения этого выражения в памяти будет выделен участок памяти, где будут храниться все данные нашего объекта. А в переменную computer будет записана ссылка на созданный объект.

5) [Можно ли наследовать конструктор?](#можно-ли-наследовать-конструктор)
 Конструктор не является членом класса, поэтому его нельзя наследовать, но с помощью super его можно вызвать. Когда нам нужно вызывать конструктор родителя? Всегда. Если в классе нет конструкторов, то конструктор по умолчанию вызывает конструктор по умолчанию своего родителя.
 https://job4j.ru/profile/exercise/21/task-view/149

6) [Что такое перегрузка конструктора?](#что-такое-перегрузка-конструктора)
Ранее мы уже упоминали, что в классе могут быть несколько конструкторов. Так вот такой механизм называется перегрузкой конструктора.

Перегрузка конструктора заключается в том, что мы можем объявить несколько конструкторов в одном классе. Конструктор – это особый метод, имя которого совпадает с именем класса. Однако с точки зрения синтаксиса языка, в некотором локальном пространстве не может быть двух одинаковых имен. Однако, в данном случае допускается объявление нескольких конструкторов, однако они должны отличаться набором параметров. Когда мы вызываем перегруженный конструктор, то из нескольких объявленных конструкторов, компилятор автоматически определяет нужный конструктор по его параметрам, которые указываются при вызове.

7) [Что такое статический метод?](#что-такое-статический-метод)
 Статические методы принадлежат классу, а не объекту, соответственно вызывать можем их без создания экземпляра класса, в котором они находятся.  Важно помнить, что из статического метода можно получить доступ только к статическим переменным или вызывать другие статические методы.
 * Когда же стоит использовать статические методы?
 1. Для доступа или управления статическими переменными и другими статическими методами, которые не зависят от объектов;

 2. Для служебных, вспомогательных классов и интерфейсов, поскольку не требуют создания объекта и соответственно, обеспечивают большую производительность;

 3. Когда методу требуется доступ лишь к статическим полям класса.

 В завершении стоит подытожить и подчеркнуть особенности статических методов:

 1. Статические методы нельзя переопределять.

 2. Статические методы не могут использовать ключевые слова this (ссылка на текущий объект) или super (ссылка на объект суперкласса);

 3. Нестатические методы могут обращаться непосредственно как к методам класса (включая статические), так и к переменным класса (включая статические);

 4. Статические методы могут обращаться к статическим переменным и статическим методам;

 5. Статические методы могут обращаться ко всем статическим переменным и другим статическим методам. Однако они не могут напрямую обращаться к переменным класса и нестатическим методам. Для этого им нужны ссылки на объект.
 
8) [Что такое не статический метод?](#что-такое-не-статический-метод)
Нестатические методы могут обращаться непосредственно как к методам класса (включая статические), так и к переменным класса (включая статические);
Не статический метод в объектно-ориентированном программировании (ООП) - это метод, который принадлежит конкретному объекту класса, а не самому классу. Он может быть вызван только на экземпляре класса и имеет доступ к его состоянию (полям) и поведению (другим методам).

Не статические методы обычно используются для выполнения операций, специфичных для каждого объекта класса. Они могут изменять состояние объекта, взаимодействовать с другими объектами и выполнять различные действия, связанные с функциональностью класса.

9) [Для чего используется ключевое слово this?](#для-чего-используется-ключевое-слово-this)
Ключевое слово this в Java используется для ссылки на текущий объект, в контексте которого оно используется. Оно позволяет обращаться к полям, методам и конструкторам текущего объекта.

Вот несколько основных случаев использования ключевого слова this в Java:

1. Доступ к полям объекта: Ключевое слово this используется для обращения к полям объекта, чтобы разрешить возможное сокрытие имени переменной. Например:

public class Person {
    private String name;

    public void setName(String name) {
        this.name = name;
    }
}


В этом примере this.name ссылается на поле name объекта класса Person, чтобы отличить его от параметра метода setName.

2. Вызов конструктора: Ключевое слово this может использоваться для вызова другого конструктора в том же классе. Это называется конструктором-помощником. Например:

public class Person {
    private String name;
    private int age;

    public Person(String name) {
        this(name, 0); // Вызов другого конструктора класса Person
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}


В этом примере конструктор Person(String name) вызывает другой конструктор Person(String name, int age) с помощью this(name, 0), чтобы избежать дублирования кода.

3. Передача текущего объекта: Ключевое слово this может использоваться для передачи текущего объекта в качестве аргумента метода или конструктора другого объекта. Например:


    class Person {
        private String name;

        public Person(String name) {
            this.name = name;
        }

        public void introduce() {
            Greeting.greet(this); // Передача текущего объекта в метод greet()
        }

        public static void main(String[] args) {
            Person person = new Person("Name");
            person.introduce();
        }


        public class Greeting {
            public static void greet(Person person) {
                System.out.println("Привет, " + person.name + "!");
            }
        }
    }



В этом примере метод introduce() класса Person передает текущий объект this (Имя переданное в конструктор класса Person при создании его экземпляра) в метод greet() класса Greeting, чтобы приветствовать человека по имени.

Ключевое слово this очень полезно для работы с объектами в Java и обеспечивает доступ к текущему объекту внутри его методов и конструкторов.

10) [Какой класс является базовый родительным классов для всех классов?](#какой-класс-является-базовый-родительным-классов-для-всех-классов)
java.lang.Object.

11) [Что такое наследование? Приведите примеры из реальной жизни.](#что-такое-наследование-приведите-примеры-из-реальной-жизни)
Наследование предназначено для создания и описания нового класса на основе уже существующего с частично или полностью заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым(родительским). Новый класс - производный класс.

12) [Опишите процесс создания нового объекта.](#опишите-процесс-создания-нового-объекта)
* Person tom = new Person();
Для создания объекта Person используется выражение new Person(). Оператор new выделяет память для объекта Person. И затем вызывается конструктор по умолчанию, который не принимает никаких параметров. В итоге после выполнения данного выражения в памяти будет выделен участок, где будут храниться все данные объекта Person. А переменная tom получит ссылку на созданный объект.
* Если конструктор не инициализирует значения переменных объекта, то они получают значения по умолчанию. Для переменных числовых типов это число 0, а для типа string и классов - это значение null (то есть фактически отсутствие значения).
https://metanit.com/java/tutorial/3.1.php

13) [Как вызвать метод из родительского класса?](#как-вызвать-метод-из-родительского-класса)
Для вызова метода из родительского класса в Java необходимо использовать ключевое слово super :

14) [Что такое переопределение метода?](#что-такое-переопределение-метода)
Переопределение позволяет задать новое поведение уже существующего метода.
Механизм переопределения (overriding) существует только при условии наследования.
На собеседовании могут спросить что такое виртуальная функция - это функция (метод), которая может быть переопределена наследником. То есть почти все нестатические методы Java - это виртуальные функции (кроме private-методов, так как они не могут быть переопределены в связи с правами видимости). Статические методы принадлежат классу и не могут быть переопределены, поэтому они не являются виртуальными функциями.

15) [Можно ли переопределить статический метод?](#можно-ли-переопределить-статический-метод)
Переопределять можно только нестатические методы. Если же мы попытаемся переопределить статический метод, это будет называться "сокрытием метода из суперкласса".

16) [Что такое виртуальная функция и используются ли они в Java?](#что-такое-виртуальная-функция-и-используются-ли-они-в-java)
Это функция (метод), которая может быть переопределена наследником. То есть почти все нестатические методы Java - это виртуальные функции (кроме private-методов, так как они не могут быть переопределены в связи с правами видимости).

17) [Что такое перегрузка метода?](#что-такое-перегрузка-метода)
Это механизм позволяющий создавать методы с одинаковыми именами, но с разными входными параметрами.
* Поясним одно понятие - сигнатура метода.
Сигнатура метода - это сочетание имени метода и список параметров вместе с типами этих параметров. Больше никакие части объявления метода не входят в сигнатуру метода. Помните об этом.
Именно поэтому изменение типа возвращаемого значения не является достаточным условием перегрузки методов, поскольку возвращаемое не входит в сигнатуру метода. Изменения должны происходить именно в сигнатуре, а если быть точнее - то в его параметрах.
* Подведем итоги и опишем ситуации, при каких условиях возможна перегрузка:

- изменение типа одного или нескольких параметров;

- изменение порядка параметров, при условии что они имеют разные типы;

- изменение количества параметров.

18) [Можно ли изменить тип возвращаемых данных при перегрузке метода?](#можно-ли-изменить-тип-возвращаемых-данных-при-перегрузке-метода)
Изменение типа возвращаемого значения не является достаточным условием перегрузки методов, поскольку возвращаемое не входит в сигнатуру метода. Изменения должны происходить именно в сигнатуре, а если быть точнее - то в его параметрах.

19) [Что такое множественное наследование? Как его можно реализовать в Java.](#что-такое-множественное-наследование-как-его-можно-реализовать-в-java)
Множественное наследование — это функция, при которой один подкласс может наследоваться от более чем одного класса. Проще говоря, класс может иметь более одного суперкласса.
Java не поддерживает множественное наследование классов, потому что это может привести к проблеме ромба (ромбовидное наследование).  Это ограничение можно обойти за счет другого механизма - полиморфизма.

20) [Что такое полиморфизм? Приведите примеры из реальной жизни.](#что-такое-полиморфизм-приведите-примеры-из-реальной-жизни)
Полиморфизм - это механизм описывающий поведение класса, но не содержащий реализации.

21) [Что такое инкапсуляция?](#что-такое-инкапсуляция)
Инкапсуляция - этот механизм используется для скрытия реализации устройства объекта от пользователей этого класса. Этот механизм позволяет относиться к объекту, как к атомарному элементу.

22) [Как реализована инкапсуляция в Java?](#как-реализована-инкапсуляция-в-java)
С помощью механизма инкапсуляции создаются объекты, которые объединяют данные и код, который управляет этими данными (переменные и методы). Основной конструкцией, где используется инкапсуляция, является класс. С помощью инкапсуляции мы собираем вместе данные и методы управления ими в класс, а с помощью механизма сокрытия производится настройка доступа к этим данным и методам управления ими. Механизм сокрытия выполнен в виде модификаторов доступа.
Модификаторов всего 4: public, protected, default и private.
Модификатор доступа располагается вначале элемента: класса, конструктора, метода, поля класса. К локальным переменным модификаторы не применяются.

public - элемент обозначенный этим модификатором доступа доступен везде в программе.

protected - элемент обозначенный этим модификатором доступа доступен внутри пакета и в наследниках.

default - данный модификатор не имеет своего ключевого слова и используется по умолчанию, если явно не указан другой модификатор (то есть это элементы без модификатора). Такие элементы видны всем классам пакета, в котором они объявлены. Не путать с ключевым словом default, применяемом к методам интерфейса (это мы будем проходить в следующем разделе).

private - элемент обозначенный этим модификатором доступа доступен внутри класса.

24. Можно ли применить модификаторы доступа к конструкторам?
К конструктору можно применять модификаторы доступа для контроля его вызова.

25. Что такое интерфейс?
Интерфейс - это абстрактный класс, в котором не реализован ни один метод. С помощью этих методов описывается некое поведение, которое должно быть реализовано в классах, применяющих этот интерфейс.

26. Перечислите элементы, которые может содержать интерфейс.
В интерфейсе могут быть объявлены поля, но на них накладываются некоторые ограничения - они должны быть проинициализированы сразу при объявлении, а также по умолчанию являются публичными (public), статическими (static) и неизменяемыми (final), то есть константами.
Интерфейс не может содержать конструкторов, так как интерфейс - это абсолютная абстракция, то есть вся реализация возложена на классы-реализации. По причине отсутствия конструкторов создать экземпляр интерфейса невозможно.

  Коротко (Интерфейсы в Java являются ссылочными типами, как классы, но они могут содержать в себе только константы, сигнатуры методов, default  методы (методы по умолчанию), static  методы (статические методы) и вложенные типы. Тела методов могут быть только у статических методов и методов по умолчанию.)

27. Можно ли создать объект интерфейса? Если да, то как?
Нельзя создать экземпляр интерфейса. Интерфейс может быть только реализован каким-либо классом, либо наследоваться другим интерфейсом. Вы создаете экземпляр класса, который реализует интерфейс.

28. Может ли интерфейс содержать какие-либо методы с реализацией? Если да, то какие?
- Статические методы.
Начнем со статических методов. Главная их особенность - они принадлежат только интерфейсу, в котором объявлены, и не наследуются ни классами, реализующими интерфейс, ни интерфейсами-наследниками.
- Дефолтные методы.
 Теперь рассмотрим дефолтные методы - так же, как и статические, они имеют реализацию, но при их объявлении используется ключевое слово default.
 Главное отличие дефолтного метода в том, что он будет унаследован классом, который реализует данный интерфейс. При этом класс может как переопределить данный метод, так и не переопределять и воспользоваться реализацией по умолчанию.
 Также дефолтные методы наследуются производными интерфейсами от базовых.
 - Приватные методы.
 Последний тип методов, которые могут быть объявлены в интерфейсах - это приватные. Они обозначаются ключевым словом private. Они могут быть как статическими, так и нестатическими. Эти методы используются в интерфейсах для того, чтобы вынести какую то логику из публичных статических или дефолтных методов, либо для предотвращения дублирования кода. В приватный метод можно убрать все детали реализации, чтобы уменьшить пользовательский код и упростить его читаемость, также в private методы нужно убирать задвоившийся код.

29. Что такое абстракция?
Абстракция - это парадигма ООП, которая подразумевает набор важных характеристик объекта, доступных из любого места программы. То есть абстракция выделяет значимые свойства объекта и отбрасывает незначимые.

30. Что такое абстрактный класс?
Абстрактный класс очень похож на обычный. Разница только в том, что абстрактный класс - это заготовка под будущую реализацию. В нем помимо обычных можно определить абстрактные методы - это методы, которые объявляются без реализации. У них нет тела и фигурных скобок. Тем самым объявляется некое поведение, но реализация перекладывается на класс-наследник. Так как абстрактный класс - это заготовка, то его экземпляр нельзя создать.

31. Сколько абстрактных методов должен и может содержать абстрактный класс?
Обычно класс называют абстрактным, если он имеет хотя бы один абстрактный метод.

32. Может ли абстрактный класс содержать обычные методы?
Методы класса не обязательно должны быть все абстрактными. Если реализация какого-либо метода общая для всех наследников, можно определить ее в абстрактном классе.

33. Сколько объектов абстрактного класса можно создать в программе?
Так как абстрактный класс - это заготовка, то его экземпляр нельзя создать.

34. Что нужно делать, если наследник абстрактного класса не переопределяет все абстрактные методы родителя?
 Все абстрактные методы должны быть переопределены в классах-наследниках. Если какой-то абстрактный метод остается не переопределённым в классе-наследнике, то класс-наследник тоже нужно объявить абстрактным.

35. Чем отличается интерфейс от абстрактного класса?
Любой интерфейс - это по существу абстрактный класс, но не наоборот.
Вы всегда будете уверены, что класс, который реализует какой-либо интерфейс, реализует и все его методы.

36. Что такое вложенные классы? Зачем они нужны?
В Java есть возможность определить класс внутри другого класса. Класс, полностью находящийся внутри другого класса, называется вложенным.
Основные случаи применения вложенных классов (всех видов):
- Это способ логической группировки классов, которые используются только в одном месте: если класс полезен только для одного другого класса, то логично встроить его в этот класс и сохранить их вместе. Вложение таких «вспомогательных классов» делает их пакет более упорядоченным.
- Это увеличивает инкапсуляцию: рассмотрим два класса верхнего уровня, A и B, где B требуется доступ к членам A, которые в противном случае были бы объявлены закрытыми. Скрывая класс B внутри класса A, члены A могут быть объявлены закрытыми, и B может получить к ним доступ. Кроме того, сам Б может быть скрыт от внешнего мира.
- Это может привести к более удобному для чтения и сопровождения коду: вложение небольших классов в классы верхнего уровня помещает код ближе к тому месту, где он используется.
(Вложенные классы предоставляют удобный способ организации и структурирования кода, а также обеспечивают инкапсуляцию и повышение безопасности.)

37. Какие типы вложенных классов существуют в Java?
Статические вложенные классы
Внутренние классы
Локальные классы
Анонимные (безымянные) классы

38. Что такое внутренний класс? Когда он применяется?
Внутренний класс (Inner Class): Это класс, объявленный внутри другого класса. Внутренний класс имеет доступ ко всем членам внешнего класса, включая приватные члены. Внутренние классы могут быть статическими или нестатическими.(?)

39. Что такое статический вложенный класс? Когда он применяется?
Статический вложенный класс (Static Nested Class): Это класс, объявленный внутри другого класса, но с модификатором static. Статический вложенный класс не имеет доступа к нестатическим членам внешнего класса и может быть использован без создания экземпляра внешнего класса.

40. Сколько объектов статического вложенного класса можно создать в программе?
Объектов статического вложенного класса можно создать сколько угодно.

41. Что такое локальный класс? Когда он применяется?
Локальный класс (Local Class): Это класс, объявленный внутри блока кода, например, внутри метода или блока if. Локальные классы имеют доступ к переменным внешнего блока кода, но только к тем, которые объявлены как final или effectively final.
В объявлении локального класса допустим только один модификатор - final, который имеет обычное значение в виде запрета наследования этого класса. Остальные модификаторы объявить невозможно, так как локальный класс не является членом внешнего класса, а относится к блоку кода, в котором он объявлен.
Время жизни локального класса ограничено блоком кода, в котором он находится (метод getFullName), либо пока в программе остаются рабочие ссылки на этот класс.
Также локальные классы не могут содержать в себе статические объявления (классы, методы и т.д.). Допустимы только переменные-константы.

42. Что такое анонимный класс? Когда он применяется?
Анонимный класс (Anonymous Class): Это класс, который не имеет имени и создается непосредственно в месте использования.
 Анонимным классом следует пользоваться, если нужен локальный класс для одноразового использования.

43. Сколько объектов анонимного класса можно создать в программе?
Так как у анонимного класса нет имени, то у него нет и конструкторов для создания экземпляров этого класса.

44. Что такое исключения? Какие типы исключительных ситуаций бывают?
Исключение — это проблема(ошибка) возникающая во время выполнения программы. Исключения могут возникать во многих случаях, например:
Пользователь ввел некорректные данные.
Файл, к которому обращается программа, не найден.
Сетевое соединение с сервером было утеряно во время передачи данных. И т.д.
Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.
https://javastudy.ru/interview/exceptions/
Throwable - базовый класс для всех нестандартных ситуаций при работе вашего приложения.

Error - ошибки связанные с работой виртуальной машины. Такие как: выход за границы памяти, использование одинаковых библиотек с разными версиями.

Exception - ошибки, которые связаны с работой самой программы. Их можно разделить на два типа: проверяемые (checked) и непроверяемые (unchecked) исключения (RuntimeException).
- проверяемыми являются исключения, которые проверяются во время компиляции программы и если такие исключения не обработать, то наша программа попросту не скомпилируется. Для обработки исключения используется блок try-catch или ключевое слово throws после сигнатуры метода. К таким исключениям относятся: готовые исключения подклассов IOException, SQLException, а также все пользовательские исключения, которые мы наследуем от класса Exception;

- соответственно непроверяемыми исключениями являются исключения, которые проверяются во время запуска программы (Runtime), т.е. если их не обработать с помощью конструкции try-catch, то наш код скомпилируется без всяких проблем. К непроверяемым исключениям относятся все наследники класса RuntimeException.
https://job4j.ru/profile/exercise/24/task-view/194

45. Назовите основные методы класса Object?

       1.Object clone() – Создает новый объект, не отличающийся от клонируемого

       2.boolean equals(Object object) – Определяет, равен ли один объект другому

       3.void finalize() – Вызывается перед удалением неиспользуемого объекта

       4.Class getClass() – Получает класс объекта во время выполнения

       5.int hashCode() – Возвращает хеш-код, связанный с вызывающим объектом

       6.void notify() – Возобновляет выполнение потока

       7.void notifyAll() – Возобновляет выполнение всех потоков

       8.String toString() – Возвращает строку, которая описывает объект

       9.void wait() – Ожидает другого потока выполнения

       10.void wait(long миллисек) – Ожидает другого потока выполнения

       11.void wait(long миллисек, int наносек) – Ожидает другого потока выполнения

46. Что такое шаблоны проектирования?

     Термин шаблон проектирование означает схему решения часто возникающей задачи проектирования.
     Есть три основных типа шаблонов проектирования:
     • структурный
     • порождающий
     • поведенческий


47. Объясните шаблон - декоратор. Придумайте пример, не относящийся к технике.

       Шаблон «Декоратор» является структурным шаблоном проектирования, который позволяет нам добавлять новое или дополнительное поведение к объекту в ходе выполнения в зависимости от ситуации.

48. Объясните шаблон - стратегия. Придумайте пример, не относящийся к технике.

       Шаблон «Стратегия» является поведенческим шаблоном проектирования, который позволяет вам решать, какой план действий должна принять программа, основываясь на определённом контексте при выполнении. Вы закладываете два различных алгоритма внутри двух классов и решаете в ходе выполнения, с какой стратегией следует работать.


49. Объясните шаблон - синглтон. Придумайте пример, не относящийся к технике.

       Шаблон проектирования «Одиночка» является порождающим шаблоном проектирования, который обеспечивает наличие одного единственного экземпляра какого-то конкретного класса во время выполнения и глобальную точку доступа к этому единственному экземпляру.

50. Объясните шаблон - фабричный метод. Придумайте пример, не относящийся к технике.

       Шаблон «Фабричный метод» является порождающим шаблоном проектирования, который делает именно то, что означает это слово: этот класс действует как фабрика экземпляров объектов.

51. Что такое enum? Когда можно его применять?

        Enum - это класс-перечисление. Перечисление - это набор констант, связанных между собой по смыслу. Константы здесь - это статические объекты, создающиеся в единственном экземпляре.
        Enum (перечисление) - это тип данных в языке программирования, который представляет собой набор именованных констант. Каждая константа в перечислении имеет свое уникальное имя и значение.

        Enum может быть полезен в различных ситуациях, например:

        1. Представление ограниченного набора значений: Если у вас есть набор значений, которые могут быть использованы для определенного свойства или состояния, вы можете использовать enum для представления этих значений. Например, дни недели (Понедельник, Вторник, и т.д.) или статусы заказа (В обработке, Отправлен, Доставлен).

        2. Улучшение читаемости кода: Использование enum может сделать ваш код более понятным и читаемым. Вместо использования числовых или строковых значений, вы можете использовать имена констант из enum, что делает код более ясным и позволяет избежать ошибок.

        3. Защита от ошибок: Enum может помочь предотвратить ошибки в вашем коде. Поскольку enum ограничивает возможные значения, компилятор может проверить, что вы используете только допустимые значения из перечисления.

        Пример использования enum в Java:

        enum DayOfWeek {
            MONDAY,
            TUESDAY,
            WEDNESDAY,
            THURSDAY,
            FRIDAY,
            SATURDAY,
            SUNDAY
        }

        public class Main {
            public static void main(String[] args) {
                DayOfWeek today = DayOfWeek.MONDAY;
                System.out.println("Today is " + today);
            }
        }


        В этом примере мы создали enum DayOfWeek, который представляет дни недели. Мы можем использовать константы из этого enum, чтобы представить дни недели в нашем коде. В данном случае, мы присвоили переменной today значение DayOfWeek.MONDAY и вывели его на экран.

        Enum - это мощный инструмент, который может сделать ваш код более ясным, безопасным и поддерживаемым.


52. Что такое record? Когда можно его применять?

      Record дает возможность записать стандартную модель данных в виде одной строки, то есть с помощью record можно избавиться от шаблонного кода, который приходится писать в каждой модели данных.

      Record - это неизменяемая модель данных, в которой:

      - Поля, переданные в параметрах, являются private и final по умолчанию.

      - Код имеет канонический конструктор, параметры которого - это все поля данного класса.

      - Доступ к полям осуществляется через методы типа имя_поля(). Тот же геттер, только без слова get в имени метода. Методов типа set класс record не имеет, так как все поля объявлены как final, поэтому record является неизменяемым.

      - Определены методы equals() и hashcode(), включающие все поля класса.

      - Определен шаблонный метод toString() для вывода полей класса на печать.

      public record PersonRecord(String name, int age) { }


53. Зачем нужны StringBuilder, StringBuffer, StringJoiner? Что они делают?

     StringBuilder, StringBuffer и StringJoiner - это классы в Java, которые используются для работы с изменяемыми строками. Они предоставляют удобные методы для создания и изменения строковых значений.

     1. StringBuilder:
        - StringBuilder является изменяемой версией строки (mutable string).
        - Он предоставляет методы для добавления, удаления и изменения символов в строке.
        - StringBuilder обычно используется в ситуациях, когда требуется эффективное построение строки, особенно если вам нужно многократно изменять строку в цикле или в многопоточной среде.
        - Он не является потокобезопасным, поэтому не рекомендуется использовать его в многопоточных приложениях без синхронизации.

     2. StringBuffer:
        - StringBuffer также является изменяемой версией строки (mutable string).
        - Он предоставляет те же методы, что и StringBuilder, но с одним отличием - StringBuffer является потокобезопасным (thread-safe).
        - StringBuffer обычно используется в многопоточных приложениях, где необходима безопасность потоков при работе с изменяемыми строками.

     3. StringJoiner:
        - StringJoiner используется для объединения строк с использованием разделителя.
        - Он предоставляет удобный способ объединения нескольких строк в одну, добавляя между ними разделитель.
        - StringJoiner позволяет указать префикс и суффикс, которые будут добавлены в начало и конец объединенной строки соответственно.
        - Этот класс особенно полезен при создании CSV-файлов, форматировании строк или любых других ситуациях, когда требуется объединение строк с определенным разделителем.

     Пример использования StringBuilder:

     StringBuilder sb = new StringBuilder();
     sb.append("Hello");
     sb.append(" ");
     sb.append("World");
     String result = sb.toString(); // "Hello World"


     Пример использования StringBuffer:

     StringBuffer sb = new StringBuffer();
     sb.append("Hello");
     sb.append(" ");
     sb.append("World");
     String result = sb.toString(); // "Hello World"


     Пример использования StringJoiner:

     StringJoiner sj = new StringJoiner(", ", "[", "]");
     sj.add("Apple");
     sj.add("Banana");
     sj.add("Orange");
     String result = sj.toString(); // "[Apple, Banana, Orange]"


     Эти классы предоставляют удобные методы для работы с изменяемыми строками и помогают улучшить производительность и эффективность вашего кода при работе с большими объемами данных или в многопоточной среде.


54. Чем отличаются StringBuffer и StringBuilder?

        1.2.3. Инкапсуляция 12. Работа со строками. StringBuilder, StringJoiner, StringBuffer.

        Обработка строк в Java. Часть I: String, StringBuffer, StringBuilder (StringBuilder, StringBuffer)

        Java 9, Полное руководство - Герберт Шилдт. Глава 17 (Разделы "Класс StringBuffer" и "Класс StringBuilder").



55. Каким образом производится экранирование символов и зачем это нужно?

        1.2.3. Инкапсуляция 13. Экранирование символов. Управляющие последовательности.



56. Что такое управляющие последовательности?

        1.2.3. Инкапсуляция 13. Экранирование символов. Управляющие последовательности.

        Java 9, Полное руководство - Герберт Шилдт. Глава 3 (Раздел "Символьные литералы").



57. Зачем нужно форматирование данных? Метод format()

        1.2.3. Инкапсуляция 9. Форматирование данных. Метод format()

        Java 9, Полное руководство - Герберт Шилдт. Глава 20 (Раздел "Класс Formatter").



58. Что такое varargs? В каких случаях стоит его применять?

        1.2.3. Инкапсуляция 15. Аргументы переменной длины (varargs)

        Java 9, Полное руководство - Герберт Шилдт. Глава 7 (Раздел "Аргументы переменной длины").



59. В каких случаях может возникнуть неоднозначность при работе с varargs?

        1.2.3. Инкапсуляция 15. Аргументы переменной длины (varargs)

        Java 9, Полное руководство - Герберт Шилдт. Глава 7 (Раздел "Аргументы переменной длины").



60. Что такое форматированный вывод? Какие механизмы позволяют осуществить форматированный вывод?